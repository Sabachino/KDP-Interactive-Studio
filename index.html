    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("App KDP inizializzata.");

            // --- CONFIGURAZIONE ---
            const NANO_BANANA_API_KEY = "YOUR_PROFESSIONAL_KEY_HERE"; 
            const NANO_BANANA_ENDPOINT = "https://api.nanobanana.com/v1/generate"; 
            const stripe = Stripe('pk_test_YOUR_STRIPE_PUBLIC_KEY'); 

            // --- STATO ---
            const state = { 
                mode: 'kindle', 
                generatedImageB64: null, 
                originalImageB64: null, 
                printFrontImage: null, 
                styleReferenceB64: null,
                elements: [], 
                selectedElementId: null, 
                idCounter: 0, 
                canvasScale: 1, 
                paperbackLayout: null,
                pickingColor: null,
                isSelectingArea: false,
                selectionStart: { x: 0, y: 0 },
                selectionRect: null,
                lastActiveMode: 'kindle'
            };
            
            // --- RIFERIMENTI DOM ---
            const els = {
                titleInput: document.getElementById('titleInput'), 
                mood: document.getElementById('mood'),
                styleGenre: document.getElementById('styleGenre'),
                runAgentsBtn: document.getElementById('runAgentsBtn'),
                modificationArea: document.getElementById('modificationArea'),
                modificationPrompt: document.getElementById('modificationPrompt'),
                modifyArtworkBtn: document.getElementById('modifyArtworkBtn'),
                undoBtn: document.getElementById('undoBtn'),
                styleRefInput: document.getElementById('styleRefInput'), 
                styleRefPreview: document.getElementById('styleRefPreview'), 
                styleRefImg: document.getElementById('styleRefImg'), 
                clearStyleRef: document.getElementById('clearStyleRef'), 
                designStudio: document.getElementById('designStudio'),
                exportSection: document.getElementById('exportSection'),
                printSection: document.getElementById('printSection'), 
                initPaperbackBtn: document.getElementById('initPaperbackBtn'),
                paperbackTools: document.getElementById('paperbackTools'),
                spineTools: document.getElementById('spineTools'), 
                spineTextInput: document.getElementById('spineTextInput'), 
                addSpineTextBtn: document.getElementById('addSpineTextBtn'), 
                centerSpineTextBtn: document.getElementById('centerSpineTextBtn'), 
                addBackTextBtn: document.getElementById('addBackTextBtn'),
                backTextInput: document.getElementById('backTextInput'), 
                centerBackTextBtn: document.getElementById('centerBackTextBtn'), 
                addBackImageInput: document.getElementById('addBackImageInput'),
                downloadPrintBtn: document.getElementById('downloadPrintBtn'),
                trimSizeInput: document.getElementById('trimSizeInput'),
                pageCountInput: document.getElementById('pageCountInput'),
                paperTypeInput: document.getElementById('paperTypeInput'), 
                spineColorInput: document.getElementById('spineColorInput'),
                backColorInput: document.getElementById('backColorInput'),
                spineWidthDisplay: document.getElementById('spineWidthDisplay'),
                totalResDisplay: document.getElementById('totalResDisplay'), 
                canvasDimensionsDisplay: document.getElementById('canvasDimensionsDisplay'), 
                addGenericTextBtn: document.getElementById('addGenericTextBtn'),
                textInspector: document.getElementById('textInspector'),
                imageInspector: document.getElementById('imageInspector'), 
                inspectorPlaceholder: document.getElementById('inspectorPlaceholder'),
                selectedTextInput: document.getElementById('selectedTextInput'),
                fontSelector: document.getElementById('fontSelector'),
                colorPicker: document.getElementById('colorPicker'),
                sizeInput: document.getElementById('sizeInput'),
                textSizeControl: document.getElementById('textSizeControl'),
                textStrokeControl: document.getElementById('textStrokeControl'),
                textSpacingControl: document.getElementById('textSpacingControl'),
                shapeSpecificControls: document.getElementById('shapeSpecificControls'),
                shapeWidthInput: document.getElementById('shapeWidthInput'),
                shapeHeightInput: document.getElementById('shapeHeightInput'),
                shapeWidthDisplay: document.getElementById('shapeWidthDisplay'),
                shapeHeightDisplay: document.getElementById('shapeHeightDisplay'),
                shapeRadiusInput: document.getElementById('shapeRadiusInput'),
                shapeRadiusDisplay: document.getElementById('shapeRadiusDisplay'),
                borderRadiusControl: document.getElementById('borderRadiusControl'),
                spacingInput: document.getElementById('spacingInput'),
                spacingValue: document.getElementById('spacingValue'),
                strokeColorPicker: document.getElementById('strokeColorPicker'),
                strokeWidthInput: document.getElementById('strokeWidthInput'),
                shadowColorPicker: document.getElementById('shadowColorPicker'),
                shadowBlurInput: document.getElementById('shadowBlurInput'),
                shadowOffsetInput: document.getElementById('shadowOffsetInput'), 
                shadowAngleInput: document.getElementById('shadowAngleInput'), 
                angleValue: document.getElementById('angleValue'),
                offsetValue: document.getElementById('offsetValue'),
                rotationInput: document.getElementById('rotationInput'),
                rotationValue: document.getElementById('rotationValue'),
                imgSizeInput: document.getElementById('imgSizeInput'), 
                imgSizeValue: document.getElementById('imgSizeValue'), 
                imgRotationInput: document.getElementById('imgRotationInput'), 
                imgRotationValue: document.getElementById('imgRotationValue'), 
                deleteImageBtn: document.getElementById('deleteImageBtn'), 
                importFrontInput: document.getElementById('importFrontInput'),
                deleteElementBtn: document.getElementById('deleteElementBtn'),
                centerElementBtn: document.getElementById('centerElementBtn'),
                addRectBtn: document.getElementById('addRectBtn'),
                addCircleBtn: document.getElementById('addCircleBtn'),
                addBadgeBtn: document.getElementById('addBadgeBtn'),
                addFlagBtn: document.getElementById('addFlagBtn'),
                addBulletBtn: document.getElementById('addBulletBtn'),
                opacityControl: document.getElementById('opacityControl'),
                opacityInput: document.getElementById('opacityInput'),
                opacityValue: document.getElementById('opacityValue'),
                aiStyleBtn: document.getElementById('aiStyleBtn'),
                downloadKindleBtn: document.getElementById('downloadKindleBtn'),
                interactiveArea: document.getElementById('interactiveArea'),
                placeholder: document.getElementById('placeholder'),
                loader: document.getElementById('loader'),
                loaderText: document.getElementById('loaderText'),
                canvasInfo: document.getElementById('canvasInfo'),
                boldBtn: document.getElementById('boldBtn'),
                italicBtn: document.getElementById('italicBtn'),
                sizeValueDisplay: document.getElementById('sizeValueDisplay'),
                textSpecificControls: document.getElementById('textSpecificControls'),
                resetRotationBtn: document.getElementById('resetRotationBtn'),
                rotateNegative90Btn: document.getElementById('rotateNegative90Btn'),
                toggleSelectModeBtn: document.getElementById('toggleSelectModeBtn'),
                selectionControls: document.getElementById('selectionControls'),
                selectionBox: document.getElementById('selectionBox'), 
                selectivePrompt: document.getElementById('selectivePrompt'),
                applySelectiveBtn: document.getElementById('applySelectiveBtn'),
                cancelSelectBtn: document.getElementById('cancelSelectBtn'),
                toggleBarcode: document.getElementById('toggleBarcode'),
                toggleGuides: document.getElementById('toggleGuides'),
                barcodeArea: document.getElementById('barcodeArea'),
                guidesOverlay: document.getElementById('guidesOverlay'),
                exportCanvas: document.getElementById('exportCanvas'),
                previewContainer: document.getElementById('previewContainer'),
                alignLeftBtn: document.getElementById('alignLeftBtn'),
                alignCenterBtn: document.getElementById('alignCenterBtn'),
                alignRightBtn: document.getElementById('alignRightBtn'),
                resetBtn: document.getElementById('resetBtn')
            };

            // Check Critico: Se il pulsante non viene trovato, l'app non funziona
            if (!els.runAgentsBtn) {
                console.error("ERRORE CRITICO: Il pulsante 'runAgentsBtn' non è stato trovato nel DOM. Controlla l'HTML.");
                alert("Errore di inizializzazione: Il pulsante Genera non esiste. Ricarica la pagina.");
            } else {
                els.runAgentsBtn.addEventListener('click', () => {
                    console.log("Pulsante Genera cliccato.");
                    generateBaseArtwork();
                });
            }

            // --- LOGICA FUNZIONALE ---
            
            function rgbToHex(r, g, b) {
                if (r > 255 || g > 255 || b > 255) throw "Invalid color component";
                return ((r << 16) | (g << 8) | b).toString(16);
            }
            
            function performReset() {
                 if(!confirm('Sei sicuro di voler resettare tutto e ricominciare da zero?')) return;
                 
                 state.mode = 'kindle';
                 state.generatedImageB64 = null;
                 state.originalImageB64 = null;
                 state.printFrontImage = null;
                 state.styleReferenceB64 = null;
                 state.elements = [];
                 state.selectedElementId = null;
                 state.idCounter = 0;
                 state.canvasScale = 1;
                 state.paperbackLayout = null;
                 state.lastActiveMode = 'kindle';
                 state.isSelectingArea = false;
                 state.selectionRect = null;
                 
                 if(els.titleInput) els.titleInput.value = '';
                 if(els.mood) els.mood.value = '';
                 if(els.styleGenre) els.styleGenre.value = 'none';
                 if(els.modificationPrompt) els.modificationPrompt.value = '';
                 if(els.selectedTextInput) els.selectedTextInput.value = '';
                 if(els.spineTextInput) els.spineTextInput.value = '';
                 if(els.backTextInput) els.backTextInput.value = '';
                 if(els.styleRefInput) els.styleRefInput.value = '';
                 if(els.importFrontInput) els.importFrontInput.value = '';
                 if(els.addBackImageInput) els.addBackImageInput.value = '';
                 
                 if(els.toggleBarcode) els.toggleBarcode.checked = false;
                 if(els.toggleGuides) els.toggleGuides.checked = false;
                 
                 if(els.interactiveArea) {
                    els.interactiveArea.innerHTML = ''; 
                    els.interactiveArea.style.backgroundImage = '';
                    els.interactiveArea.classList.add('hidden');
                    safeAppend(els.interactiveArea, els.guidesOverlay);
                    safeAppend(els.interactiveArea, els.barcodeArea);
                    safeAppend(els.interactiveArea, els.selectionBox);
                    els.interactiveArea.style.width = '';
                    els.interactiveArea.style.height = '';
                 }
                 if(els.placeholder) els.placeholder.classList.remove('hidden');
                 
                 if(els.modificationArea) els.modificationArea.classList.add('hidden');
                 if(els.designStudio) els.designStudio.classList.add('hidden');
                 if(els.printSection) els.printSection.classList.add('hidden');
                 if(els.exportSection) els.exportSection.classList.add('hidden');
                 if(els.textInspector) els.textInspector.classList.add('hidden');
                 if(els.imageInspector) els.imageInspector.classList.add('hidden');
                 if(els.inspectorPlaceholder) els.inspectorPlaceholder.classList.remove('hidden');
                 if(els.paperbackTools) els.paperbackTools.classList.add('hidden');
                 if(els.spineTools) els.spineTools.classList.add('hidden');
                 if(els.downloadPrintBtn) els.downloadPrintBtn.classList.add('hidden');
                 if(els.canvasDimensionsDisplay) els.canvasDimensionsDisplay.classList.add('hidden');
                 if(els.guidesOverlay) els.guidesOverlay.classList.add('hidden');
                 if(els.barcodeArea) els.barcodeArea.classList.add('hidden');
                 if(els.selectionBox) els.selectionBox.style.display = 'none';
                 if(els.styleRefPreview) els.styleRefPreview.classList.add('hidden');
                 if(els.clearStyleRef) els.clearStyleRef.classList.add('hidden');
                 if(els.canvasInfo) els.canvasInfo.classList.add('hidden');
                 
                 if(els.toggleSelectModeBtn) {
                    els.toggleSelectModeBtn.innerHTML = '<i class="fa-regular fa-square"></i> Definisci Area';
                    els.toggleSelectModeBtn.className = 'w-full bg-pink-500 hover:bg-pink-400 text-white text-shadow-black text-xs py-2 rounded shadow transition-colors flex items-center justify-center gap-2 font-bold mb-2';
                 }
            }

            // FIX CRITICAL: Funzione helper sicura per appendere elementi DOM evitando errori se già presenti
            function safeAppend(parent, child) {
                if (!parent || !child) return;
                if (child.parentNode === parent) return; // Già presente
                if (child.parentNode) child.parentNode.removeChild(child);
                parent.appendChild(child);
            }

            async function applyAiStyle() {
                alert("Configura la API Key Google Gemini nel codice per usare questa funzione.");
            }

            function updateShadow() {
                const el = state.elements.find(e => e.id === state.selectedElementId);
                const domEl = document.getElementById(state.selectedElementId);
                if(el && domEl) {
                    const c = els.shadowColorPicker.value;
                    const b = els.shadowBlurInput.value;
                    const o = els.shadowOffsetInput.value;
                    const a = els.shadowAngleInput.value || 45;
                    const rad = a * (Math.PI / 180);
                    const x = (o * Math.cos(rad)).toFixed(1);
                    const y = (o * Math.sin(rad)).toFixed(1);
                    const shadowVal = b > 0 || o > 0 ? `${x}px ${y}px ${b}px ${c}` : 'none';
                    if (el.type === 'text') { el.style.textShadow = shadowVal; domEl.style.textShadow = shadowVal; } 
                    else if (el.type === 'shape') { el.style.boxShadow = b > 0 || o > 0 ? `${x}px ${y}px ${b}px ${c}` : 'none'; domEl.style.boxShadow = el.style.boxShadow; }
                    el.shadowProps = { color: c, blur: b, offset: o, angle: a };
                }
            }
            
            function updateAlignment(align) {
                if(!state.selectedElementId) return;
                const el = state.elements.find(e => e.id === state.selectedElementId);
                if(el && el.type === 'text') {
                    el.style.textAlign = align;
                    const domEl = document.getElementById(state.selectedElementId);
                    if(domEl) domEl.style.textAlign = align;
                    els.alignLeftBtn.classList.toggle('active', align === 'left');
                    els.alignCenterBtn.classList.toggle('active', align === 'center');
                    els.alignRightBtn.classList.toggle('active', align === 'right');
                }
            }

            function updatePrintCalculations() {
                const [w, h] = els.trimSizeInput.value.split('x').map(parseFloat);
                const pages = parseInt(els.pageCountInput.value) || 100;
                const paperType = els.paperTypeInput.value;

                let paperThickness = 0.002252; // White (Standard)
                if (paperType === 'cream') paperThickness = 0.0025;
                else if (paperType === 'color') paperThickness = 0.002347;

                const spine = pages * paperThickness; 
                const bleed = 0.125; 
                
                const totalW_inch = bleed + w + spine + w + bleed;
                const totalH_inch = bleed + h + bleed;
                
                const dpi = 300;
                const pxW = Math.ceil(totalW_inch * dpi);
                const pxH = Math.ceil(totalH_inch * dpi);
                
                els.spineWidthDisplay.innerText = `${spine.toFixed(3)}"`;
                if(els.totalResDisplay) els.totalResDisplay.innerText = `${pxW} x ${pxH} px`;
                
                if(state.mode === 'paperback') {
                    els.canvasDimensionsDisplay.innerHTML = `<i class="fa-solid fa-ruler-combined mr-2"></i>DIMENSIONE TOTALE FILE: <b>${pxW} x ${pxH} px</b> (300 DPI)`;
                }

                return { pxW, pxH, frontPx: w*dpi, spinePx: spine*dpi, bleedPx: bleed*dpi, trimW: w, trimH: h, spineInch: spine };
            }

            function initKindleCanvas() {
                state.mode = 'kindle';
                state.isSelectingArea = false;
                els.selectionBox.style.display = 'none';
                els.selectionControls.classList.add('hidden');
                els.toggleSelectModeBtn.innerHTML = '<i class="fa-regular fa-square"></i> Definisci Area';
                els.toggleSelectModeBtn.className = 'w-full bg-pink-500 hover:bg-pink-400 text-white text-shadow-black text-xs py-2 rounded shadow transition-colors flex items-center justify-center gap-2 font-bold mb-2';

                els.interactiveArea.style.width = '400px';
                els.interactiveArea.style.height = '517.65px'; 
                els.interactiveArea.style.backgroundImage = `url(${state.generatedImageB64})`;
                els.interactiveArea.style.backgroundSize = 'cover';
                els.interactiveArea.style.backgroundPosition = 'center';
                els.interactiveArea.style.backgroundRepeat = 'no-repeat';
                els.placeholder.classList.add('hidden');
                els.interactiveArea.classList.remove('hidden');
                els.canvasInfo.classList.remove('hidden');
                els.paperbackTools.classList.add('hidden');
                els.spineTools.classList.add('hidden'); 
                els.downloadPrintBtn.classList.add('hidden');
                els.canvasDimensionsDisplay.classList.add('hidden'); 
                
                els.barcodeArea.classList.add('hidden'); 

                els.interactiveArea.innerHTML = '';
                safeAppend(els.interactiveArea, els.guidesOverlay); 
                els.guidesOverlay.classList.add('hidden'); 
                safeAppend(els.interactiveArea, els.selectionBox); 
                
                state.elements.forEach(el => renderElementDOM(el));
            }

            // ---------------------------------------------------------
            // FIX: GESTIONE PAPERBACK MODE + RESIZE OBSERVER
            // ---------------------------------------------------------
            function initPaperbackMode() {
                // 1. Validazione
                if(!state.generatedImageB64 && !state.printFrontImage) return alert("Genera prima la copertina o importa un'immagine!");
                
                // 2. Aggiornamento Stato
                const wasKindle = (state.mode === 'kindle');
                state.mode = 'paperback';
                state.isSelectingArea = false;

                // 3. UI Reset
                els.selectionBox.style.display = 'none'; 
                els.selectionControls.classList.add('hidden');
                els.placeholder.classList.add('hidden');
                
                // Reset toggle
                if(els.toggleSelectModeBtn) {
                    els.toggleSelectModeBtn.innerHTML = '<i class="fa-regular fa-square"></i> Definisci Area';
                    els.toggleSelectModeBtn.className = 'w-full bg-pink-600 hover:bg-pink-500 text-white text-shadow-black text-xs py-2 rounded shadow transition-colors flex items-center justify-center gap-2 font-bold mb-2';
                }

                // FIX CRITICO: Pulizia stili inline Kindle prima del calcolo
                els.interactiveArea.style.width = '';
                els.interactiveArea.style.height = '';
                els.interactiveArea.classList.remove('hidden');
                els.canvasInfo.classList.remove('hidden');

                // 4. Calcolo Geometria con doppio requestAnimationFrame per garantire che il DOM sia pronto
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const calc = updatePrintCalculations();
                        const ratio = calc.pxW / calc.pxH;
                        
                        // Misura il container reale
                        const containerPadding = 40; 
                        const rect = els.previewContainer.getBoundingClientRect();
                        const availableW = rect.width - containerPadding;
                        const availableH = rect.height - containerPadding; 

                        if (availableW <= 0 || availableH <= 0) return; // Non visibile ancora

                        let viewW, viewH;
                        const containerRatio = availableW / availableH;

                        // Algoritmo "Contain"
                        if (ratio > containerRatio) {
                            viewW = availableW;
                            viewH = viewW / ratio;
                        } else {
                            viewH = availableH;
                            viewW = viewH * ratio;
                        }
                        
                        // Applica Dimensioni
                        els.interactiveArea.style.width = viewW + 'px';
                        els.interactiveArea.style.height = viewH + 'px';
                        
                        // Visualizza Info
                        els.canvasDimensionsDisplay.classList.remove('hidden');
                        els.canvasDimensionsDisplay.innerHTML = `<i class="fa-solid fa-ruler-combined mr-2"></i>FILE TOTALE: <b>${calc.pxW} x ${calc.pxH} px</b> (300 DPI)`;
                        
                        // 5. Generazione Canvas Background
                        generatePaperbackBackground(calc, calc.pxW, calc.pxH);
                        
                        // 6. Elementi Interni (Guide, Barcode)
                        setupInternalElements(calc, viewW, viewH);

                        // 7. Scala e Posizionamento
                        const scale = viewW / calc.pxW;
                        state.paperbackLayout = calc;
                        state.canvasScale = scale;
                        
                        // UI Tools
                        els.paperbackTools.classList.remove('hidden');
                        els.spineTools.classList.remove('hidden'); 
                        els.downloadPrintBtn.classList.remove('hidden');

                        // 8. Migrazione Elementi
                        if (wasKindle) migrateElementsToPaperback(calc, scale);
                        
                        // Rendering Elementi
                        const oldDraggables = els.interactiveArea.querySelectorAll('.draggable-item');
                        oldDraggables.forEach(d => d.remove());
                        state.elements.forEach(el => renderElementDOM(el));

                        // Posiziona Barcode
                        updateBarcodePosition(calc, viewW, viewH, scale);

                        // Scroll automatico
                        setTimeout(() => {
                            els.spineTools.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 100);
                    });
                });
            }

            // Funzione helper per il background
            function generatePaperbackBackground(calc, pxW, pxH) {
                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = pxW; bgCanvas.height = pxH;
                const ctx = bgCanvas.getContext('2d');
                
                const frontImg = new Image();
                frontImg.onload = () => {
                    ctx.fillStyle = els.backColorInput.value; 
                    ctx.fillRect(0,0, pxW, pxH);
                    
                    ctx.fillStyle = els.spineColorInput.value;
                    const backCoverWidth = calc.bleedPx + calc.frontPx; 
                    ctx.fillRect(backCoverWidth, 0, calc.spinePx, pxH);

                    const fx = backCoverWidth + calc.spinePx;
                    const fw = calc.frontPx + calc.bleedPx; 
                    const fh = pxH; 

                    const imgR = frontImg.width / frontImg.height;
                    const targetR = fw / fh;
                    
                    let dW, dH, dX, dY;
                    if (imgR > targetR) { 
                        dH = fh; dW = fh * imgR; dX = fx + (fw - dW)/2; dY = 0; 
                    } else { 
                        dW = fw; dH = fw / imgR; dX = fx; dY = (fh - dH)/2; 
                    }
                    
                    ctx.save(); 
                    ctx.beginPath(); 
                    ctx.rect(fx, 0, fw, fh); 
                    ctx.clip();
                    ctx.drawImage(frontImg, 0, 0, frontImg.width, frontImg.height, dX, dY, dW, dH);
                    ctx.restore();
                    
                    els.interactiveArea.style.backgroundImage = `url(${bgCanvas.toDataURL()})`;
                    els.interactiveArea.style.backgroundSize = 'contain'; 
                };
                frontImg.src = state.printFrontImage || state.generatedImageB64;
            }

            function setupInternalElements(calc, viewW, viewH) {
                // FIX: Usa safeAppend per evitare crash DOMException
                if (!els.interactiveArea.contains(els.guidesOverlay)) safeAppend(els.interactiveArea, els.guidesOverlay);
                if (!els.interactiveArea.contains(els.barcodeArea)) safeAppend(els.interactiveArea, els.barcodeArea);
                if (!els.interactiveArea.contains(els.selectionBox)) safeAppend(els.interactiveArea, els.selectionBox);

                els.guidesOverlay.classList.add('hidden');
                els.barcodeArea.classList.add('hidden');
                
                if(els.toggleBarcode.checked) els.barcodeArea.classList.remove('hidden');
                if(els.toggleGuides.checked) {
                    drawKDPGuides(calc, viewW, viewH);
                    els.guidesOverlay.classList.remove('hidden');
                }
            }

            function updateBarcodePosition(calc, viewW, viewH, scale) {
                const backCoverPanelWidth = calc.bleedPx + calc.frontPx; 
                const visualBackEnd = backCoverPanelWidth * scale;
                const visualBarcodeLeft = visualBackEnd - 100; 
                const visualBottom = viewH - (calc.bleedPx * scale) - 70; 
                els.barcodeArea.style.left = visualBarcodeLeft + 'px';
                els.barcodeArea.style.top = visualBottom + 'px';
            }

            function migrateElementsToPaperback(calc, scale) {
                const kindleWidth = 400; 
                const frontCoverVisualWidth = (calc.frontPx + calc.bleedPx) * scale;
                const frontCoverStartX = (calc.bleedPx + calc.frontPx + calc.spinePx) * scale;
                const elementScale = frontCoverVisualWidth / kindleWidth;
                
                state.elements.forEach(el => {
                    el.x = (el.x * elementScale) + frontCoverStartX;
                    el.y = (el.y * elementScale);
                    let fSize = parseFloat(el.style.fontSize);
                    el.style.fontSize = (fSize * elementScale) + 'px';
                    if(el.type === 'shape' || el.type === 'image') {
                        el.width = el.width * elementScale;
                        if(el.height) el.height = el.height * elementScale;
                    }
                });
            }

            // FIX: Observer per resize fluido
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (state.mode === 'paperback' && state.paperbackLayout) {
                        // Debounce leggero per performance
                        requestAnimationFrame(() => initPaperbackMode());
                    }
                }
            });
            resizeObserver.observe(els.previewContainer);

            function drawKDPGuides(calc, viewW, viewH) {
                const guideContainer = els.guidesOverlay;
                guideContainer.innerHTML = '';
                
                const scale = viewW / calc.pxW;
                const bleed = calc.bleedPx * scale;
                const safe = (0.25 * 300) * scale;
                const spineStart = (calc.bleedPx + calc.frontPx) * scale;
                const spineWidth = calc.spinePx * scale;
                
                const trimBox = document.createElement('div');
                trimBox.className = 'kdp-trim-line';
                trimBox.style.left = bleed + 'px'; trimBox.style.top = bleed + 'px';
                trimBox.style.width = (viewW - (bleed * 2)) + 'px'; trimBox.style.height = (viewH - (bleed * 2)) + 'px';
                guideContainer.appendChild(trimBox);
                
                const topBleed = document.createElement('div'); topBleed.className = 'kdp-bleed-zone';
                topBleed.style.top = '0'; topBleed.style.left = '0'; topBleed.style.width = '100%'; topBleed.style.height = bleed + 'px';
                guideContainer.appendChild(topBleed);
                
                const botBleed = document.createElement('div'); botBleed.className = 'kdp-bleed-zone';
                botBleed.style.bottom = '0'; botBleed.style.left = '0'; botBleed.style.width = '100%'; botBleed.style.height = bleed + 'px';
                guideContainer.appendChild(botBleed);
                
                const leftBleed = document.createElement('div'); leftBleed.className = 'kdp-bleed-zone';
                leftBleed.style.top = bleed+'px'; leftBleed.style.left = '0'; leftBleed.style.width = bleed + 'px'; leftBleed.style.height = (viewH - bleed*2) + 'px';
                guideContainer.appendChild(leftBleed);
                
                const rightBleed = document.createElement('div'); rightBleed.className = 'kdp-bleed-zone';
                rightBleed.style.top = bleed+'px'; rightBleed.style.right = '0'; rightBleed.style.width = bleed + 'px'; rightBleed.style.height = (viewH - bleed*2) + 'px';
                guideContainer.appendChild(rightBleed);

                const spineFold = document.createElement('div');
                spineFold.className = 'kdp-spine-fold';
                spineFold.style.left = spineStart + 'px'; spineFold.style.top = '0px'; spineFold.style.width = spineWidth + 'px';
                guideContainer.appendChild(spineFold);

                const backSafe = document.createElement('div');
                backSafe.className = 'kdp-safe-zone';
                backSafe.style.left = (bleed + safe) + 'px'; backSafe.style.top = (bleed + safe) + 'px';
                const spineSafeMargin = (0.0625 * 300) * scale;
                backSafe.style.width = (spineStart - (bleed + safe) - spineSafeMargin) + 'px';
                backSafe.style.height = (viewH - (bleed * 2) - (safe * 2)) + 'px';
                guideContainer.appendChild(backSafe);

                const frontSafe = document.createElement('div');
                frontSafe.className = 'kdp-safe-zone';
                frontSafe.style.left = (spineStart + spineWidth + spineSafeMargin) + 'px';
                frontSafe.style.top = (bleed + safe) + 'px';
                frontSafe.style.width = (viewW - (spineStart + spineWidth) - (bleed + safe) - spineSafeMargin) + 'px';
                frontSafe.style.height = (viewH - (bleed * 2) - (safe * 2)) + 'px';
                guideContainer.appendChild(frontSafe);
            }

            function addElement(type, content) {
                 const id = `el_${state.idCounter++}`;
                let el = { 
                    id, type, content, x: 50, y: 50, rotation: 0,
                    style: { color: '#ffffff', fontSize: 30, fontFamily: "'Inter', sans-serif", fontWeight: 'normal', fontStyle: 'normal', letterSpacing: '0px', webkitTextStrokeColor: '#000000', webkitTextStrokeWidth: '0px', textShadow: 'none', opacity: 1, textAlign: 'center' }, 
                    shadowProps: { color: '#000000', blur: 0, offset: 0, angle: 45 }
                };
                if(type === 'image') { el.width = 150; el.src = content; }
                else if (type === 'shape') { 
                    el.width = 100; el.height = 100; el.shapeType = content; el.style.color = '#F59E0B'; el.borderRadius = 0;
                }
                
                state.elements.push(el); renderElementDOM(el); selectElement(id);
                return id; 
            }
            
            function addSpineText() {
                 if(state.mode !== 'paperback') return alert("Passa prima al formato Paperback!");
                 let text = els.spineTextInput.value;
                 if(!text) text = "TESTO SPINA"; 
                 
                 const id = addElement('text', text); 
                 els.spineTextInput.value = '';
                 
                 const el = state.elements.find(e => e.id === id);
                 const domEl = document.getElementById(id);
                 
                 if(el && domEl) {
                     el.style.fontSize = 12; el.style.fontWeight = 'normal'; domEl.style.fontSize = '12px'; domEl.style.fontWeight = 'normal';
                     
                     // FIX: Calcolo immediato della posizione basato sullo stato attuale
                     const calc = state.paperbackLayout || updatePrintCalculations();
                     const viewW = parseFloat(els.interactiveArea.style.width);
                     const scale = viewW / calc.pxW;
                     
                     const spineCenterPx = calc.bleedPx + calc.frontPx + (calc.spinePx / 2);
                     const spineCenterX = spineCenterPx * scale;
                     const spineCenterY = (calc.pxH / 2) * scale;
                     
                     updateElementById(id, 'rotation', -90);
                     
                     domEl.style.width = 'auto'; 
                     domEl.style.height = 'auto';
                     
                     setTimeout(() => {
                         const w = domEl.offsetWidth; 
                         const h = domEl.offsetHeight; 
                         
                         const finalX = spineCenterX - (h / 2);
                         const finalY = spineCenterY - (w / 2);

                         updateElementById(id, 'x', finalX);
                         updateElementById(id, 'y', finalY);
                         
                         els.designStudio.classList.remove('hidden');
                         els.textInspector.classList.remove('hidden');
                         els.designStudio.scrollIntoView({ behavior: 'smooth', block: 'center' });
                     }, 50);
                 }
            }
            
            function addBackText() {
                 if(state.mode !== 'paperback') return alert("Passa prima al formato Paperback!");
                 let text = els.backTextInput.value;
                 if(!text) text = "TESTO RETRO"; 
                 
                 const id = addElement('text', text);
                 els.backTextInput.value = '';
                 
                 setTimeout(() => {
                     centerBackText(); 
                     els.designStudio.classList.remove('hidden');
                     els.textInspector.classList.remove('hidden');
                     els.designStudio.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 }, 50);
            }
            
            function centerSpineText() {
                if(!state.selectedElementId) return;
                const calc = updatePrintCalculations(); 
                const viewW = els.interactiveArea.clientWidth; 
                const scale = viewW / calc.pxW; 
                const spineCenterPx = calc.bleedPx + calc.frontPx + (calc.spinePx / 2);
                const spineCenterX = spineCenterPx * scale;
                const dom = document.getElementById(state.selectedElementId);
                if(!dom) return;
                const w = dom.offsetWidth;
                const h = dom.offsetHeight;
                
                updateElementById(state.selectedElementId, 'x', spineCenterX - (h/2));
            }
            
            function centerBackText() {
                if(!state.selectedElementId) return;
                const calc = updatePrintCalculations(); 
                const viewW = els.interactiveArea.clientWidth; 
                const scale = viewW / calc.pxW; 
                const backCenterPx = calc.bleedPx + (calc.frontPx / 2); 
                const backCenterVisualX = backCenterPx * scale;
                const domEl = document.getElementById(state.selectedElementId);
                if (!domEl) return;
                const w = domEl.offsetWidth;
                updateElementById(state.selectedElementId, 'x', backCenterVisualX - (w/2));
            }

            function handleImageUpload(e) {
                const file = e.target.files[0];
                if(file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        addElement('image', evt.target.result);
                        setTimeout(() => {
                            if (!els.imageInspector.classList.contains('hidden')) {
                                els.imageInspector.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }, 100);
                    };
                    reader.readAsDataURL(file);
                }
            }

            function renderElementDOM(el) {
                const div = document.createElement('div');
                div.id = el.id;
                div.className = 'draggable-item';
                
                if(el.type === 'text') {
                    div.innerText = el.content || 'Testo';
                } else if (el.type === 'image') {
                    const img = document.createElement('img'); img.src = el.src; img.style.width = el.width + 'px'; div.appendChild(img);
                } else if (el.type === 'shape') {
                    div.style.width = el.width + 'px';
                    div.style.height = (el.height || el.width) + 'px'; 
                    
                    if (el.shapeType === 'triangle') {
                        div.style.backgroundColor = 'transparent'; div.style.width = '0'; div.style.height = '0'; 
                        div.style.borderLeft = (el.width/2) + 'px solid transparent';
                        div.style.borderRight = (el.width/2) + 'px solid transparent';
                        div.style.borderBottom = (el.height || el.width) + 'px solid ' + el.style.color;
                        div.style.borderRadius = '0';
                    } else if (el.shapeType === 'badge') {
                        div.style.backgroundColor = el.style.color;
                        const points = []; const spikes = 40; const outer = 50; const inner = 45; const cx = 50; const cy = 50;
                        for(let i=0; i<spikes*2; i++){
                            const r = (i%2 === 0) ? outer : inner;
                            const angle = (Math.PI * i) / spikes;
                            const x = cx + r * Math.cos(angle);
                            const y = cy + r * Math.sin(angle);
                            points.push(`${x.toFixed(1)}% ${y.toFixed(1)}%`);
                        }
                        div.style.clipPath = `polygon(${points.join(',')})`;
                        div.style.borderRadius = '0';
                    } else if (el.shapeType === 'flag') {
                        div.style.backgroundColor = el.style.color;
                        div.style.clipPath = 'polygon(0% 0%, 100% 0%, 80% 50%, 100% 100%, 0% 100%)';
                        div.style.borderRadius = '0';
                    } else if (el.shapeType === 'bullet') {
                        div.style.display = 'flex'; div.style.alignItems = 'center'; div.style.justifyContent = 'center'; 
                        const icon = document.createElement('div');
                        icon.style.width = '20px'; icon.style.height = '20px'; icon.style.borderRadius = '50%';
                        icon.style.backgroundColor = el.style.color; icon.style.flexShrink = '0';
                        icon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                        div.appendChild(icon);
                        div.style.backgroundColor = 'transparent';
                    } else {
                        div.style.backgroundColor = el.style.color;
                        if (el.shapeType === 'circle') div.style.borderRadius = '50%';
                        else if (el.shapeType === 'rect') div.style.borderRadius = (el.borderRadius || 0) + 'px';
                        else div.style.borderRadius = '0';
                    }
                }
                
                applyStyles(div, el);
                div.addEventListener('mousedown', startDrag);
                div.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    if(state.mode === 'selecting') return;
                    selectElement(el.id);
                    if(el.type === 'text' || el.type === 'shape') {
                        els.designStudio.classList.remove('hidden');
                        els.designStudio.scrollIntoView({behavior: 'smooth', block: 'center'});
                    }
                });
                els.interactiveArea.appendChild(div);
            }

            function applyStyles(div, el) {
                div.style.left = el.x + 'px'; div.style.top = el.y + 'px'; div.style.transform = `rotate(${el.rotation}deg)`; div.style.zIndex = 200; 
                div.style.opacity = el.style.opacity; 
                
                if(el.type === 'text') {
                    Object.assign(div.style, {
                        color: el.style.color, fontFamily: el.style.fontFamily, 
                        fontWeight: el.style.fontWeight, fontStyle: el.style.fontStyle, letterSpacing: el.style.letterSpacing, webkitTextStrokeColor: el.style.webkitTextStrokeColor, 
                        webkitTextStrokeWidth: el.style.webkitTextStrokeWidth, textShadow: el.style.textShadow, textAlign: el.style.textAlign
                    });
                    
                    let size = el.style.fontSize;
                    if (typeof size === 'string' && size.includes('px')) { div.style.fontSize = size; } 
                    else { div.style.fontSize = size + 'px'; }
                    div.innerText = el.content;
                } else if (el.type === 'image') {
                    const img = div.querySelector('img');
                    if(img) img.style.width = el.width + 'px';
                } else if (el.type === 'shape') {
                      const h = el.height || el.width;
                      div.style.boxShadow = el.style.boxShadow || 'none';

                      if (el.shapeType === 'triangle') {
                        div.style.borderBottomColor = el.style.color;
                        div.style.borderLeftWidth = (el.width/2) + 'px';
                        div.style.borderRightWidth = (el.width/2) + 'px';
                        div.style.borderBottomWidth = h + 'px';
                        div.style.boxShadow = 'none'; 
                      } else if (el.shapeType === 'badge' || el.shapeType === 'flag') {
                        div.style.backgroundColor = el.style.color;
                        div.style.width = el.width + 'px';
                        div.style.height = h + 'px';
                      } else if (el.shapeType === 'bullet') {
                          const icon = div.querySelector('div');
                          if(icon) icon.style.backgroundColor = el.style.color;
                          div.style.width = el.width + 'px';
                      } else {
                        div.style.backgroundColor = el.style.color;
                        div.style.width = el.width + 'px';
                        div.style.height = h + 'px';
                        if (el.shapeType === 'rect') div.style.borderRadius = (el.borderRadius || 0) + 'px';
                      }
                }
            }

            let dragged = null, startX=0, startY=0;
            function startDrag(e) { 
                if(state.mode === 'selecting') return;
                dragged = e.currentTarget; const rect = dragged.getBoundingClientRect(); startX = e.clientX - rect.left; startY = e.clientY - rect.top; selectElement(dragged.id); document.addEventListener('mousemove', onDrag); document.addEventListener('mouseup', endDrag); 
            }
            function onDrag(e) { if(!dragged) return; const cont = els.interactiveArea.getBoundingClientRect(); const x = e.clientX - cont.left - startX; const y = e.clientY - cont.top - startY; dragged.style.left = x + 'px'; dragged.style.top = y + 'px'; const el = state.elements.find(i => i.id === dragged.id); if(el) { el.x = x; el.y = y; } }
            function endDrag() { dragged = null; document.removeEventListener('mousemove', onDrag); document.removeEventListener('mouseup', endDrag); }

            function selectElement(id) {
                state.selectedElementId = id;
                els.inspectorPlaceholder.classList.add('hidden');
                const el = state.elements.find(e => e.id === id);
                if(el) {
                    els.textInspector.classList.remove('hidden');
                    els.imageInspector.classList.add('hidden');
                    els.colorPicker.value = el.style.color;
                    els.opacityInput.value = el.style.opacity || 1;
                    els.opacityValue.innerText = Math.round((el.style.opacity || 1) * 100) + '%';
                    els.rotationInput.value = el.rotation;
                    els.rotationValue.innerText = el.rotation + '°';
                    
                    if(el.type === 'text') {
                        els.textSpecificControls.classList.remove('hidden'); 
                        els.shapeSpecificControls.classList.add('hidden');
                        els.textSizeControl.classList.remove('hidden');
                        els.textSpacingControl.classList.remove('hidden');
                        els.textStrokeControl.classList.remove('hidden');
                        els.opacityControl.classList.remove('hidden');
                        
                        els.selectedTextInput.value = el.content;
                        
                        let currentSize = el.style.fontSize;
                        if(typeof currentSize === 'string') currentSize = parseInt(currentSize.replace('px',''));
                        els.sizeInput.value = currentSize || 30;
                        if(els.sizeValueDisplay) els.sizeValueDisplay.innerText = (currentSize || 30) + 'px';
                        
                        els.boldBtn.classList.toggle('active', el.style.fontWeight === 'bold');
                        els.italicBtn.classList.toggle('active', el.style.fontStyle === 'italic');
                        
                        els.alignLeftBtn.classList.toggle('active', el.style.textAlign === 'left');
                        els.alignCenterBtn.classList.toggle('active', el.style.textAlign === 'center');
                        els.alignRightBtn.classList.toggle('active', el.style.textAlign === 'right');
                        
                        const angle = el.shadowProps ? el.shadowProps.angle : 45; els.shadowAngleInput.value = angle; els.angleValue.innerText = angle + '°';
                    } else if (el.type === 'image') {
                        els.textInspector.classList.add('hidden'); els.imageInspector.classList.remove('hidden');
                        els.imgSizeInput.value = el.width; els.imgSizeValue.innerText = el.width;
                        els.imgRotationInput.value = el.rotation; els.imgRotationValue.innerText = el.rotation + '°';
                    } else if (el.type === 'shape') {
                        els.textSpecificControls.classList.add('hidden');
                        els.textSizeControl.classList.add('hidden');
                        els.textSpacingControl.classList.add('hidden');
                        els.textStrokeControl.classList.add('hidden');
                        els.shapeSpecificControls.classList.remove('hidden');
                        els.opacityControl.classList.remove('hidden');
                        
                        els.shapeWidthInput.value = el.width; els.shapeWidthDisplay.innerText = el.width + 'px';
                        els.shapeHeightInput.value = el.height || el.width; els.shapeHeightDisplay.innerText = (el.height || el.width) + 'px';
                        const angle = el.shadowProps ? el.shadowProps.angle : 45; els.shadowAngleInput.value = angle; els.angleValue.innerText = angle + '°';

                        if(el.shapeType === 'rect') {
                            els.borderRadiusControl.classList.remove('hidden');
                            els.shapeRadiusInput.value = el.borderRadius || 0;
                            els.shapeRadiusDisplay.innerText = (el.borderRadius || 0) + 'px';
                        } else {
                            els.borderRadiusControl.classList.add('hidden');
                        }
                    }
                }
            }

            function updateSelectedElement(prop, value) {
                if (!state.selectedElementId) return;
                const el = state.elements.find(e => e.id === state.selectedElementId);
                const domEl = document.getElementById(state.selectedElementId);
                if (el && domEl) {
                    el[prop] = value;
                    if(prop === 'rotation') domEl.style.transform = `rotate(${value}deg)`;
                    else if(prop === 'content' && el.type === 'text') domEl.innerText = value;
                    else if(prop === 'width') {
                          if(el.type === 'image') { const img = domEl.querySelector('img'); if(img) img.style.width = value + 'px'; } 
                          else if (el.type === 'shape') {
                             const h = el.height || el.width; 
                             if (el.shapeType === 'triangle') { domEl.style.borderLeftWidth = (value/2) + 'px'; domEl.style.borderRightWidth = (value/2) + 'px'; } 
                             else if (el.shapeType === 'bullet') { domEl.style.width = value + 'px'; }
                             else { domEl.style.width = value + 'px'; }
                          }
                    } else if (prop === 'height' && el.type === 'shape') {
                          if (el.shapeType === 'triangle') { domEl.style.borderBottomWidth = value + 'px'; }
                          else if (el.shapeType === 'bullet') { }
                          else { domEl.style.height = value + 'px'; }
                    } else if (prop === 'borderRadius' && el.type === 'shape' && el.shapeType === 'rect') {
                          domEl.style.borderRadius = value + 'px';
                    }
                }
            }
            
            function updateElementById(id, prop, value) {
                const el = state.elements.find(e => e.id === id);
                const domEl = document.getElementById(id);
                if (el && domEl) {
                    el[prop] = value;
                    if(prop === 'rotation') domEl.style.transform = `rotate(${value}deg)`;
                    else if(prop === 'x') domEl.style.left = value + 'px';
                    else if(prop === 'y') domEl.style.top = value + 'px';
                }
            }
            
            function updateElement(prop, val) {
                 const el = state.elements.find(e => e.id === state.selectedElementId);
                 if(el) {
                     el[prop] = val;
                     const dom = document.getElementById(el.id);
                     if(prop === 'rotation') dom.style.transform = `rotate(${val}deg)`;
                     else if (prop === 'x') dom.style.left = val + 'px';
                 }
            }

            function updateSelectedStyle(styleProp, value) {
                if (!state.selectedElementId) return;
                const el = state.elements.find(e => e.id === state.selectedElementId);
                const domEl = document.getElementById(state.selectedElementId);
                if (el && domEl) {
                    el.style[styleProp] = value;
                    if (el.type === 'shape') {
                        if (el.shapeType === 'triangle' && styleProp === 'color') domEl.style.borderBottomColor = value;
                        else if (styleProp === 'color' && el.shapeType === 'bullet') {
                             const icon = domEl.querySelector('div');
                             if(icon) icon.style.backgroundColor = value;
                             el.style.color = value;
                        }
                        else if (styleProp === 'color') domEl.style.backgroundColor = value;
                        else domEl.style[styleProp] = value;
                    } else applyStyles(domEl, el);
                }
            }
            
            function deleteSelectedElement() {
                if(state.selectedElementId) {
                    const domEl = document.getElementById(state.selectedElementId);
                    if (domEl) domEl.remove();
                    state.elements = state.elements.filter(e => e.id !== state.selectedElementId);
                    state.selectedElementId = null;
                    els.textInspector.classList.add('hidden');
                    els.imageInspector.classList.add('hidden');
                    els.inspectorPlaceholder.classList.remove('hidden');
                }
            }

            function centerSelectedElement() {
                if(state.selectedElementId) {
                    const dom = document.getElementById(state.selectedElementId);
                    if (dom) {
                        const containerW = els.interactiveArea.offsetWidth;
                        const elW = dom.offsetWidth;
                        const newX = (containerW - elW) / 2;
                        updateElement('x', newX);
                        dom.style.left = newX + 'px';
                    }
                }
            }

            // --- MODIFICATO: FIX GENERAZIONE ---
            async function generateBaseArtwork() {
                console.log("Inizio generazione...");
                
                // Controllo elementi critici
                if(!els.loader || !els.loaderText) {
                    console.error("Elementi UI mancanti per il loader.");
                    alert("Errore interno: interfaccia non caricata correttamente.");
                    return;
                }

                if(!els.titleInput || !els.mood) {
                    alert("Errore: campi Titolo o Tema non trovati.");
                    return;
                }

                if(!els.titleInput.value || !els.mood.value) return alert("Compila i campi Titolo e Tema!");
                
                els.loader.classList.remove('hidden');
                els.loaderText.innerText = "la tua cover è in arrivo..........";
                
                els.modificationPrompt.value = ''; 
                state.mode = 'kindle';
                state.lastActiveMode = 'kindle'; 
                
                try {
                    console.log("Iniziando generazione con API...");
                    const title = els.titleInput.value || "";
                    const mood = els.mood.value || "";
                    const mockPrompt = `${title} ${mood} book cover design, high quality, vertical aspect ratio`;
                    const randomSeed = Math.floor(Math.random() * 99999);
                    
                    // FIX: URL API corretto e codificato
                    const apiUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(mockPrompt)}?width=800&height=1200&nologo=true&seed=${randomSeed}&model=flux`;
                    
                    console.log("Fetching:", apiUrl);

                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        console.error("Response non OK:", response.status);
                        throw new Error(`Errore server API: ${response.status}`);
                    }
                    
                    const blob = await response.blob();
                    console.log("Blob ricevuto, dimensione:", blob.size);

                    const reader = new FileReader();
                    reader.onloadend = function() {
                        console.log("Immagine convertita in Base64.");
                        state.generatedImageB64 = reader.result;
                        state.originalImageB64 = state.generatedImageB64;
                        
                        initKindleCanvas(); 
                        
                        els.modificationArea.classList.remove('hidden');
                        els.designStudio.classList.remove('hidden');
                        els.printSection.classList.remove('hidden');
                        els.exportSection.classList.remove('hidden');
                        
                        if(typeof updatePrintCalculations === 'function') updatePrintCalculations();
                        
                        state.elements = [];
                        state.idCounter = 0;
                        
                        els.loader.classList.add('hidden');
                        console.log("Generazione completata con successo.");
                    }
                    reader.readAsDataURL(blob);

                } catch (error) {
                    console.error("ERRORE CRITICO API:", error);
                    els.loader.classList.add('hidden');
                    
                    let errorMsg = "Errore generazione immagine: " + error.message;
                    if(error.message.includes("Failed to fetch")) {
                        errorMsg += "\n\nNota: Se stai aprendo il file direttamente dal computer (file://), il browser potrebbe bloccare la connessione. Prova a usare un server locale (es. Live Server in VS Code).";
                    }
                    alert(errorMsg);
                }
            }
            
            function renderAndDownload(type) {
                if (!state.generatedImageB64 && !state.printFrontImage) return alert("Nessun design da esportare!");

                let price, itemName;
                if(type === 'kindle') {
                    price = "10.00€"; itemName = "Kindle Cover HD (JPG)";
                } else {
                    price = "20.00€"; itemName = "KDP Print Layout (300DPI)";
                }

                if(confirm(`Vuoi procedere al pagamento di ${price} per scaricare ${itemName}?`)) {
                    els.loader.classList.remove('hidden'); 
                    els.loaderText.innerText = "Reindirizzamento a Stripe in corso...";
                    setTimeout(() => {
                        els.loaderText.innerText = "Pagamento riuscito! Generazione file...";
                        setTimeout(() => { executeDownloadGeneration(type); }, 1000);
                    }, 1500);
                }
            }

            function executeDownloadGeneration(type) {
                    try {
                        const canvas = els.exportCanvas;
                        const ctx = canvas.getContext('2d');
                        let targetW, targetH;
                        let scaleFactor = 1;

                        if (type === 'kindle') {
                            targetW = 1600; targetH = 2400;
                            const viewW = parseFloat(els.interactiveArea.style.width) || 400;
                            scaleFactor = targetW / viewW;
                        } else {
                            const calc = updatePrintCalculations();
                            targetW = calc.pxW; targetH = calc.pxH;
                            const viewW = parseFloat(els.interactiveArea.style.width);
                            if (!viewW) throw new Error("Errore dimensioni canvas. Riprova a generare il layout.");
                            scaleFactor = targetW / viewW;
                        }

                        canvas.width = targetW; canvas.height = targetH;
                        
                        const performDraw = (bgImg) => {
                            if (type === 'kindle') {
                                     const r = bgImg.width / bgImg.height; const tr = targetW / targetH;
                                     let dw, dh, dx, dy;
                                     if(r > tr) { dh = targetH; dw = targetH * r; dx = (targetW-dw)/2; dy=0; }
                                     else { dw = targetW; dh = targetW / r; dy = (targetH-dh)/2; dx=0; }
                                     ctx.drawImage(bgImg, dx, dy, dw, dh);
                            } else {
                                     const calc = updatePrintCalculations();
                                     ctx.fillStyle = els.backColorInput.value; ctx.fillRect(0,0, targetW, targetH);
                                     ctx.fillStyle = els.spineColorInput.value;
                                     const spineStart = calc.bleedPx + calc.frontPx; 
                                     ctx.fillRect(spineStart, 0, calc.spinePx, targetH);

                                     const fx = spineStart + calc.spinePx;
                                     const fw = calc.frontPx + calc.bleedPx; const fh = targetH;
                                     
                                     const imgR = bgImg.width / bgImg.height;
                                     const targetR = fw / fh;
                                     let dW, dH, dX, dY;
                                     if (imgR > targetR) { dH = fh; dW = fh * imgR; dX = fx + (fw - dW)/2; dY = 0; } 
                                     else { dW = fw; dH = fw / imgR; dX = fx; dY = (fh - dH)/2; }
                                     
                                     ctx.save(); ctx.beginPath(); ctx.rect(fx, 0, fw, fh); ctx.clip();
                                     ctx.drawImage(bgImg, dX, dY, dW, dH);
                                     ctx.restore();
                            }

                            state.elements.forEach(el => {
                                 ctx.save();
                                 let rectW = 0, rectH = 0;
                                 const domEl = document.getElementById(el.id);
                                 if (domEl) { rectW = domEl.offsetWidth; rectH = domEl.offsetHeight; } 
                                 else { rectW = el.width || 100; rectH = el.height || el.width || 100; }

                                 const scaledW = rectW * scaleFactor;
                                 const scaledH = rectH * scaleFactor;
                                 const centerX = (el.x * scaleFactor) + (scaledW / 2);
                                 const centerY = (el.y * scaleFactor) + (scaledH / 2);

                                 ctx.translate(centerX, centerY);
                                 ctx.rotate(el.rotation * Math.PI / 180);
                                 ctx.globalAlpha = el.style.opacity || 1;

                                 const drawX = -scaledW / 2; const drawY = -scaledH / 2;
                                 
                                 if(el.type === 'text') {
                                     const fSize = parseFloat(window.getComputedStyle(domEl).fontSize) * scaleFactor;
                                     ctx.font = `${el.style.fontWeight} ${el.style.fontStyle} ${fSize}px ${el.style.fontFamily.replace(/'/g, "")}`;
                                     ctx.fillStyle = el.style.color;
                                     ctx.textBaseline = 'middle'; ctx.textAlign = el.style.textAlign || 'center';
                                     
                                     if(el.shadowProps) {
                                          ctx.shadowColor = el.shadowProps.color;
                                          ctx.shadowBlur = el.shadowProps.blur * scaleFactor;
                                          const rad = el.shadowProps.angle * (Math.PI/180);
                                          ctx.shadowOffsetX = el.shadowProps.offset * Math.cos(rad) * scaleFactor;
                                          ctx.shadowOffsetY = el.shadowProps.offset * Math.sin(rad) * scaleFactor;
                                     }

                                     let textX = 0; const paddingOffset = 4 * scaleFactor;
                                     if (el.style.textAlign === 'center') textX = 0;
                                     else if (el.style.textAlign === 'right') textX = (scaledW / 2) - paddingOffset;
                                     else textX = (-scaledW / 2) + paddingOffset;
                                     
                                     ctx.fillText(el.content, textX, 0); 
                                     
                                     if(parseFloat(el.style.webkitTextStrokeWidth) > 0) {
                                          ctx.strokeStyle = el.style.webkitTextStrokeColor;
                                          ctx.lineWidth = parseFloat(el.style.webkitTextStrokeWidth) * scaleFactor;
                                          ctx.strokeText(el.content, textX, 0); 
                                     }
                                 } else if (el.type === 'image') {
                                     const img = domEl.querySelector('img');
                                     if(img) { ctx.drawImage(img, drawX, drawY, scaledW, scaledH); }
                                 } else if (el.type === 'shape') {
                                     ctx.fillStyle = el.style.color;
                                     if(el.shadowProps) {
                                          ctx.shadowColor = el.shadowProps.color;
                                          ctx.shadowBlur = el.shadowProps.blur * scaleFactor;
                                          const rad = el.shadowProps.angle * (Math.PI/180);
                                          ctx.shadowOffsetX = el.shadowProps.offset * Math.cos(rad) * scaleFactor;
                                          ctx.shadowOffsetY = el.shadowProps.offset * Math.sin(rad) * scaleFactor;
                                     }

                                     if(el.shapeType === 'rect') {
                                          const r = (el.borderRadius || 0) * scaleFactor;
                                          ctx.beginPath();
                                          ctx.moveTo(drawX + r, drawY);
                                          ctx.lineTo(drawX + scaledW - r, drawY);
                                          ctx.quadraticCurveTo(drawX + scaledW, drawY, drawX + scaledW, drawY + r);
                                          ctx.lineTo(drawX + scaledW, drawY + scaledH - r);
                                          ctx.quadraticCurveTo(drawX + scaledW, drawY + scaledH, drawX + scaledW - r, drawY + scaledH);
                                          ctx.lineTo(drawX + r, drawY + scaledH);
                                          ctx.quadraticCurveTo(drawX, drawY + scaledH, drawX, drawY + scaledH - r);
                                          ctx.lineTo(drawX, drawY + r);
                                          ctx.quadraticCurveTo(drawX, drawY, drawX + r, drawY);
                                          ctx.closePath();
                                          ctx.fill();
                                     }
                                     else if(el.shapeType === 'circle') {
                                          ctx.beginPath(); ctx.ellipse(0, 0, scaledW/2, scaledH/2, 0, 0, 2*Math.PI); ctx.fill();
                                     } 
                                     else if (el.shapeType === 'triangle') {
                                          ctx.beginPath(); ctx.moveTo(0, -scaledH/2); ctx.lineTo(drawX + scaledW, drawY + scaledH); ctx.lineTo(drawX, drawY + scaledH); ctx.fill();
                                     }
                                     else {
                                          ctx.fillRect(drawX, drawY, scaledW, scaledH); 
                                     }
                                 }
                                 ctx.restore();
                            });

                            try {
                                const link = document.createElement('a');
                                link.download = `cover-${type}-${Date.now()}.jpg`;
                                link.href = canvas.toDataURL('image/jpeg', 0.92);
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                            } catch(err) {
                                alert("Errore generazione file (canvas troppo grande?). Riprova.");
                            }
                            els.loader.classList.add('hidden');
                        };

                        const imgSource = (type === 'print' && state.printFrontImage) ? state.printFrontImage : state.generatedImageB64;
                        if (!imgSource) {
                            alert("Immagine sorgente mancante.");
                            els.loader.classList.add('hidden');
                            return;
                        }

                        const bgImg = new Image();
                        bgImg.crossOrigin = "anonymous";
                        bgImg.onload = () => performDraw(bgImg);
                        bgImg.onerror = () => { alert("Errore caricamento immagine per esportazione."); els.loader.classList.add('hidden'); };
                        bgImg.src = imgSource;

                    } catch(e) {
                        console.error(e);
                        alert("Errore durante l'esportazione: " + e.message);
                        els.loader.classList.add('hidden');
                    }
            }
            
            els.toggleBarcode.addEventListener('change', (e) => {
                if(e.target.checked) els.barcodeArea.classList.remove('hidden');
                else els.barcodeArea.classList.add('hidden');
            });

            els.toggleGuides.addEventListener('change', (e) => {
                if(e.target.checked) {
                    if(state.mode === 'paperback') {
                          if (!state.paperbackLayout) state.paperbackLayout = updatePrintCalculations();
                          const viewW = parseFloat(els.interactiveArea.style.width);
                          const viewH = parseFloat(els.interactiveArea.style.height);
                          drawKDPGuides(state.paperbackLayout, viewW, viewH);
                          els.guidesOverlay.classList.remove('hidden');
                    }
                } else els.guidesOverlay.classList.add('hidden');
            });

            // --- EVENT LISTENERS ---
            // (runAgentsBtn already attached above for safety)
            
            els.modifyArtworkBtn.addEventListener('click', () => { alert("Work in progress!"); });
            els.undoBtn.addEventListener('click', () => { alert("Undo non disponibile nella demo."); });
            
            els.addGenericTextBtn.addEventListener('click', () => { addElement('text', ''); setTimeout(() => els.selectedTextInput.focus(), 50); });
            els.centerElementBtn.addEventListener('click', centerSelectedElement);
            els.downloadKindleBtn.addEventListener('click', () => renderAndDownload('kindle'));
            els.downloadPrintBtn.addEventListener('click', () => renderAndDownload('print'));
            
            els.trimSizeInput.addEventListener('change', () => { updatePrintCalculations(); if(state.mode === 'paperback') initPaperbackMode(); });
            els.pageCountInput.addEventListener('input', () => { updatePrintCalculations(); if(state.mode === 'paperback') initPaperbackMode(); });
            els.paperTypeInput.addEventListener('change', () => { updatePrintCalculations(); if(state.mode === 'paperback') initPaperbackMode(); });
            
            els.spineColorInput.addEventListener('input', () => { if(state.mode === 'paperback') initPaperbackMode(); });
            els.backColorInput.addEventListener('input', () => { if(state.mode === 'paperback') initPaperbackMode(); });
            
            els.initPaperbackBtn.addEventListener('click', initPaperbackMode);
            
            els.addSpineTextBtn.addEventListener('click', addSpineText);
            els.centerSpineTextBtn.addEventListener('click', centerSpineText);
            
            els.addBackTextBtn.addEventListener('click', addBackText);
            els.centerBackTextBtn.addEventListener('click', centerBackText);
            
            els.addBackImageInput.addEventListener('change', handleImageUpload);
            
            els.selectedTextInput.addEventListener('input', (e) => updateSelectedElement('content', e.target.value));
            els.fontSelector.addEventListener('change', (e) => updateSelectedStyle('fontFamily', e.target.value));
            els.colorPicker.addEventListener('input', (e) => updateSelectedStyle('color', e.target.value));

            els.sizeInput.addEventListener('input', (e) => { 
                els.sizeValueDisplay.innerText = e.target.value + 'px'; 
                const el = state.elements.find(el => el.id === state.selectedElementId);
                if (el) {
                    if (el.type === 'text') updateSelectedStyle('fontSize', e.target.value + 'px'); 
                    else if (el.type === 'shape') updateSelectedElement('width', parseInt(e.target.value));
                }
            });

            els.shapeWidthInput.addEventListener('input', (e) => {
                els.shapeWidthDisplay.innerText = e.target.value + 'px';
                updateSelectedElement('width', parseInt(e.target.value));
            });
            els.shapeHeightInput.addEventListener('input', (e) => {
                els.shapeHeightDisplay.innerText = e.target.value + 'px';
                updateSelectedElement('height', parseInt(e.target.value));
            });
            els.shapeRadiusInput.addEventListener('input', (e) => {
                els.shapeRadiusDisplay.innerText = e.target.value + 'px';
                updateSelectedElement('borderRadius', parseInt(e.target.value));
            });

            els.spacingInput.addEventListener('input', (e) => { els.spacingValue.innerText = e.target.value + 'px'; updateSelectedStyle('letterSpacing', e.target.value + 'px'); });
            
            els.strokeColorPicker.addEventListener('input', (e) => updateSelectedStyle('webkitTextStrokeColor', e.target.value));
            els.strokeWidthInput.addEventListener('input', (e) => updateSelectedStyle('webkitTextStrokeWidth', e.target.value + 'px'));
            els.shadowColorPicker.addEventListener('input', updateShadow);
            els.shadowBlurInput.addEventListener('input', updateShadow);
            els.shadowOffsetInput.addEventListener('input', (e) => { els.offsetValue.innerText = e.target.value + 'px'; updateShadow(); });
            els.shadowAngleInput.addEventListener('input', (e) => { els.angleValue.innerText = e.target.value + '°'; updateShadow(); });
            els.rotationInput.addEventListener('input', (e) => { els.rotationValue.innerText = e.target.value + '°'; updateSelectedElement('rotation', parseInt(e.target.value)); });
            els.resetRotationBtn.addEventListener('click', () => { if(state.selectedElementId) { els.rotationInput.value = 0; els.rotationValue.innerText = '0°'; updateSelectedElement('rotation', 0); } });
            els.rotateNegative90Btn.addEventListener('click', () => { if(state.selectedElementId) { els.rotationInput.value = -90; els.rotationValue.innerText = '-90°'; updateSelectedElement('rotation', -90); } });
            
            els.imgSizeInput.addEventListener('input', (e) => { els.imgSizeValue.innerText = e.target.value; updateSelectedElement('width', parseInt(e.target.value)); });
            els.imgRotationInput.addEventListener('input', (e) => { els.imgRotationValue.innerText = e.target.value + '°'; updateSelectedElement('rotation', parseInt(e.target.value)); });
            
            els.opacityInput.addEventListener('input', (e) => { const val = e.target.value; els.opacityValue.innerText = Math.round(val * 100) + '%'; updateSelectedStyle('opacity', val); });
            
            els.deleteImageBtn.addEventListener('click', deleteSelectedElement);
            els.deleteElementBtn.addEventListener('click', deleteSelectedElement);
            els.aiStyleBtn.addEventListener('click', applyAiStyle);
            
            els.boldBtn.addEventListener('click', () => { const el = state.elements.find(e => e.id === state.selectedElementId); if(el) { const v = el.style.fontWeight === 'bold' ? 'normal' : 'bold'; updateSelectedStyle('fontWeight', v); els.boldBtn.classList.toggle('active'); } });
            els.italicBtn.addEventListener('click', () => { const el = state.elements.find(e => e.id === state.selectedElementId); if(el) { const v = el.style.fontStyle === 'italic' ? 'normal' : 'italic'; updateSelectedStyle('fontStyle', v); els.italicBtn.classList.toggle('active'); } });
            
            els.alignLeftBtn.addEventListener('click', () => updateAlignment('left'));
            els.alignCenterBtn.addEventListener('click', () => updateAlignment('center'));
            els.alignRightBtn.addEventListener('click', () => updateAlignment('right'));

            els.importFrontInput.addEventListener('change', (e) => { const f = e.target.files[0]; if(f) { const r = new FileReader(); r.onload = (ev) => { state.printFrontImage = ev.target.result; if(state.mode==='paperback') initPaperbackMode(); else alert("Img importata"); }; r.readAsDataURL(f); } });
            els.styleRefInput.addEventListener('change', (e) => { const f = e.target.files[0]; if(f) { const r = new FileReader(); r.onload = (ev) => { state.styleReferenceB64 = ev.target.result.split(',')[1]; els.styleRefImg.src = ev.target.result; els.styleRefPreview.classList.remove('hidden'); els.clearStyleRef.classList.remove('hidden'); }; r.readAsDataURL(f); } });
            els.clearStyleRef.addEventListener('click', () => { state.styleReferenceB64 = null; els.styleRefInput.value = ''; els.styleRefPreview.classList.add('hidden'); els.clearStyleRef.classList.add('hidden'); });

            els.resetBtn.addEventListener('click', performReset);
            
            els.addRectBtn.addEventListener('click', () => addElement('shape', 'rect'));
            els.addCircleBtn.addEventListener('click', () => addElement('shape', 'circle'));
            els.addBadgeBtn.addEventListener('click', () => addElement('shape', 'badge'));
            els.addFlagBtn.addEventListener('click', () => addElement('shape', 'flag'));
            els.addBulletBtn.addEventListener('click', () => addElement('shape', 'bullet'));
        });
    </script>