<!DOCTYPE html>
<html lang="it">
<head>
    <script src="https://js.stripe.com/v3/"></script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KDP Cover Designer Pro - Interactive Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Anton&family=Bebas+Neue&family=Bodoni+Moda&family=Cabin&family=Cinzel&family=Cormorant+Garamond&family=Dancing+Script&family=Great+Vibes&family=Inter:wght@400;700;900&family=Lato&family=Libre+Baskerville&family=Lobster&family=Lora&family=Merriweather&family=Montserrat:wght@400;700;900&family=Nunito&family=Open+Sans&family=Oswald&family=Pacifico&family=Playfair+Display:wght@400;700;900&family=Poppins&family=Quicksand&family=Raleway&family=Roboto&family=Roboto+Condensed&family=Satisfy&family=Source+Sans+Pro&family=Ubuntu&family=Work+Sans&family=Creepster&family=Nosifer&family=Rye&display=swap" rel="stylesheet">

    <style>
        /* FIX LAYOUT: Impedisce lo scroll della pagina intera */
        body { font-family: 'Inter', sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        
        .banana-loader {
            width: 48px; height: 48px; border: 5px solid #FFF; border-bottom-color: #FFD700;
            border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* UI Elements */
        optgroup { color: #F59E0B; font-weight: 700; background-color: #111827; }
        option { color: white; background-color: #1F2937; font-weight: normal; }

        .text-shadow-black { text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8); }
        .text-shadow-strong { text-shadow: 2px 2px 4px #000000, 0 0 4px #000000; }

        /* INTERACTIVE CANVAS STYLES */
        #interactiveArea {
            position: relative;
            overflow: hidden;
            user-select: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            background-color: #1a202c;
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            margin: 0 auto;
            flex-shrink: 0; /* Cruciale */
        }
        
        .draggable-item {
            position: absolute; cursor: move; border: none !important; outline: none !important;
            background: transparent; box-shadow: none !important; padding: 4px;
            min-width: 20px; min-height: 1.2em; display: inline-block; white-space: nowrap;
            transform-origin: center center; z-index: 200; line-height: 1.1; 
        }
        .draggable-item:empty { width: 50px; height: 30px; display: inline-block; }
        .draggable-item:hover, .draggable-item.selected, .draggable-item:focus { border: 1px dashed rgba(255, 255, 255, 0.5) !important; outline: none !important; }
        .cursor-crosshair { cursor: crosshair !important; }

        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #F59E0B; cursor: pointer; margin-top: -5px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4B5563; border-radius: 2px; }
        input[type=range]:disabled::-webkit-slider-thumb { background: #4B5563; cursor: not-allowed; }

        .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .style-btn.active { background-color: #F59E0B; color: #111827; border-color: #F59E0B; }
        .toggle-checkbox:checked { right: 0; border-color: #F59E0B; }
        .toggle-checkbox:checked + .toggle-label { background-color: #F59E0B; }
        .toggle-checkbox:checked + .toggle-label:before { transform: translateX(100%); }
        .toggle-label { width: 32px; height: 18px; background-color: #4B5563; border-radius: 9999px; position: relative; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .toggle-label:before { content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background-color: white; border-radius: 50%; transition: transform 0.2s ease-in-out; }

        .custom-scrollbar::-webkit-scrollbar { width: 5px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #111827; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #374151; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #4B5563; }
        
        #selectionBox { position: absolute; border: 2px dashed #ef4444; background-color: rgba(239, 68, 68, 0.2); pointer-events: none; z-index: 100; display: none; }
        #barcodeArea { position: absolute; width: 90px; height: 55px; background-color: #ffffff; align-items: center; justify-content: center; z-index: 1000; pointer-events: auto; box-shadow: 0 0 5px rgba(0,0,0,0.3); border: 4px solid white; flexDirection: column; }
        #barcodeLines { width: 100%; height: 80%; background-image: repeating-linear-gradient(90deg, #000 0px, #000 2px, #fff 2px, #fff 3px, #000 3px, #000 5px, #fff 5px, #fff 6px, #000 6px, #000 9px, #fff 9px, #fff 11px); }
        #barcodeText { width: 100%; text-align: center; font-family: 'Courier New', monospace; font-size: 8px; color: black; height: 20%; line-height: 10px; background: white; font-weight: bold; }

        #guidesOverlay { position: absolute; inset: 0; pointer-events: none; z-index: 990; }
        .kdp-bleed-zone { position: absolute; background-color: rgba(236, 72, 153, 0.3); z-index: 991; }
        .kdp-safe-zone { position: absolute; border: 1px dashed #ef4444; z-index: 992; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1); }
        .kdp-spine-fold { position: absolute; border-left: 1px dashed #ef4444; border-right: 1px dashed #ef4444; height: 100%; background-color: rgba(0, 0, 0, 0.1); z-index: 991; }
        .kdp-trim-line { position: absolute; border: 1px dashed #000; pointer-events: none; z-index: 993; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen selection:bg-yellow-500 selection:text-gray-900">

    <nav class="bg-gray-800 border-b border-gray-700 p-2 flex-none z-50 shadow-lg h-14 flex items-center">
        <div class="w-full px-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-layer-group text-yellow-400 text-xl"></i>
                <h1 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-yellow-400 to-orange-500">KDP Interactive Studio</h1>
            </div>
            <div class="flex items-center gap-3">
                <div class="text-[10px] font-mono text-gray-400 bg-gray-700 px-2 py-0.5 rounded-full hidden md:block">
                    <i class="fa-solid fa-pen-ruler mr-1"></i>Design Mode
                </div>
                <button id="resetBtn" type="button" class="bg-red-600 hover:bg-red-500 text-white px-3 py-1 rounded-full text-[10px] font-bold transition-colors flex items-center gap-1 cursor-pointer" title="Resetta tutto">
                    <i class="fa-solid fa-rotate-right"></i> Reset
                </button>
            </div>
        </div>
    </nav>

    <div class="w-full px-4 py-2 flex flex-row gap-3 flex-1 overflow-hidden h-[calc(100vh-3.5rem)]">
        
        <div class="w-[380px] flex-shrink-0 flex flex-col gap-3 overflow-y-auto custom-scrollbar pr-1 pb-16">
            
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg border border-gray-700 border-l-4 border-l-fuchsia-300 flex-shrink-0">
                <h2 class="text-sm font-semibold mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-brain text-fuchsia-300"></i> 
                    <span class="bg-clip-text text-transparent bg-gradient-to-r from-fuchsia-200 to-pink-400">1. Generazione Artwork</span>
                </h2>
                <div class="space-y-2">
                    <div>
                        <label class="text-[10px] text-gray-400 uppercase font-bold">Titolo Libro</label>
                        <input type="text" id="titleInput" class="w-full bg-gray-900 border border-gray-600 rounded p-1.5 mt-0.5 text-xs text-white focus:border-yellow-500 outline-none font-bold" placeholder="Es. Pinocchio">
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400 uppercase font-bold">Tema</label>
                        <textarea id="mood" rows="2" class="w-full bg-gray-900 border border-gray-600 rounded p-1.5 mt-0.5 text-xs text-white focus:border-yellow-500 outline-none" placeholder="Descrivi il soggetto..."></textarea>
                    </div>
                    <div>
                        <label class="text-[10px] text-gray-400 uppercase font-bold">Stile</label>
                        <select id="styleGenre" class="w-full bg-gray-900 border border-gray-600 rounded p-1.5 mt-0.5 text-xs text-white focus:border-yellow-500 outline-none">
                            <option value="none">Nessuno</option>
                            <option value="fantasy">Fantasy</option>
                            <option value="realistic">Realistico</option>
                            <option value="vintage">Vintage</option>
                            <option value="business">Business</option>
                            <option value="cinematic">Cinematico</option>
                            <option value="narrative">Narrativa</option>
                        </select>
                    </div>
                    
                    <button type="button" id="runAgentsBtn" class="w-full bg-gradient-to-r from-violet-500 to-blue-500 hover:from-violet-400 hover:to-blue-400 text-white text-shadow-black font-bold py-2 px-4 rounded shadow-lg mt-1 transition-all duration-200 transform hover:scale-105 flex justify-center items-center gap-2 text-xs">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> Genera
                    </button>
                    
                    <div id="modificationArea" class="hidden mt-2 pt-2 border-t border-gray-700 animate-fade-in bg-gray-900 rounded p-1.5">
                        <label class="text-[10px] text-yellow-100 uppercase font-bold mb-1 block"><i class="fa-solid fa-paintbrush mr-1"></i>Modifica Globale</label>
                        <textarea id="modificationPrompt" rows="1" class="w-full bg-gray-800 border border-gray-600 rounded p-1.5 text-xs text-white focus:border-yellow-500 outline-none mb-1" placeholder="Es. Più nebbia..."></textarea>
                        
                        <div class="grid grid-cols-2 gap-1">
                            <button type="button" id="modifyArtworkBtn" class="bg-purple-500 hover:bg-purple-400 text-white text-shadow-black font-bold py-1 px-2 rounded shadow text-[10px] flex justify-center items-center gap-1">
                                <i class="fa-solid fa-wand-sparkles"></i> Applica
                            </button>
                            <button type="button" id="undoBtn" class="bg-gray-600 hover:bg-gray-500 text-white text-shadow-black font-bold py-1 px-2 rounded shadow text-[10px] flex justify-center items-center gap-1">
                                <i class="fa-solid fa-rotate-left"></i> Annulla
                            </button>
                        </div>

                          <div class="mt-2 pt-1 border-t border-gray-700">
                             <label class="text-[10px] text-yellow-100 uppercase font-bold mb-1 block"><i class="fa-solid fa-eraser mr-1"></i>Modifica Selettiva</label>
                             <button id="toggleSelectModeBtn" class="w-full bg-pink-500 hover:bg-pink-400 text-white text-shadow-black text-[10px] py-1 rounded shadow transition-colors flex items-center justify-center gap-1 font-bold mb-1">
                                <i class="fa-regular fa-square"></i> Definisci Area
                            </button>
                            
                            <div id="selectionControls" class="hidden space-y-1 animate-fade-in">
                                <textarea id="selectivePrompt" rows="1" class="w-full bg-gray-800 border border-red-500/50 rounded p-1.5 text-xs text-white focus:border-red-500 outline-none" placeholder="Cosa fare?"></textarea>
                                <div class="flex gap-1">
                                    <button id="applySelectiveBtn" class="flex-1 bg-red-600 hover:bg-red-500 text-white py-1 rounded text-[10px] font-bold">Esegui</button>
                                    <button id="cancelSelectBtn" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white py-1 rounded text-[10px]">Annulla</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-2 pt-2 border-t border-gray-700 flex items-center justify-between">
                        <label class="text-[9px] uppercase font-bold flex items-center gap-1 text-purple-200">
                            <i class="fa-solid fa-image"></i> Ref. Img
                        </label>
                        <div class="flex items-center gap-1">
                            <label class="cursor-pointer bg-purple-300 hover:bg-purple-200 text-gray-900 px-2 py-0.5 rounded text-[9px] font-bold shadow">
                                Upload <input type="file" id="styleRefInput" accept="image/*" class="hidden">
                            </label>
                            <div id="styleRefPreview" class="w-5 h-5 bg-gray-900 rounded border border-gray-600 hidden overflow-hidden">
                                <img id="styleRefImg" class="w-full h-full object-cover">
                            </div>
                            <button id="clearStyleRef" class="hidden text-red-400 hover:text-red-300 text-[10px]"><i class="fa-solid fa-times"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="designStudio" class="hidden bg-gray-800 p-4 rounded-lg border border-gray-700 border-l-4 border-l-yellow-500 space-y-3 flex-shrink-0">
                <h2 class="text-sm font-semibold text-yellow-400 flex items-center gap-2"><i class="fa-solid fa-font"></i> 2. Personalizzazione</h2>
                
                <div class="grid grid-cols-2 gap-1">
                    <button id="addGenericTextBtn" class="bg-gray-700 hover:bg-gray-600 px-2 py-1.5 rounded font-bold text-white border border-gray-500 shadow-md text-xs flex items-center justify-center gap-1">
                        <i class="fa-solid fa-font text-yellow-400"></i> Testo
                    </button>
                    <div class="flex gap-1">
                         <button id="addRectBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white rounded border border-gray-500 flex items-center justify-center shadow-md text-xs"><i class="fa-regular fa-square text-orange-400"></i></button>
                         <button id="addCircleBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white rounded border border-gray-500 flex items-center justify-center shadow-md text-xs"><i class="fa-regular fa-circle text-orange-400"></i></button>
                    </div>
                </div>
                
                <div class="grid grid-cols-3 gap-1 mt-1">
                    <button id="addFlagBtn" class="bg-gray-700 hover:bg-gray-600 text-white rounded border border-gray-500 shadow-md py-1 text-[10px]" title="Flag"><i class="fa-solid fa-bookmark text-green-400 mr-1"></i> Flag</button>
                    <button id="addBulletBtn" class="bg-gray-700 hover:bg-gray-600 text-white rounded border border-gray-500 shadow-md py-1 text-[10px]" title="Elenco"><i class="fa-solid fa-list-ul text-blue-400 mr-1"></i> Elenco</button>
                    <button id="addBadgeBtn" class="bg-gray-700 hover:bg-gray-600 text-white rounded border border-gray-500 shadow-md py-1 text-[10px]" title="Bollino"><i class="fa-solid fa-certificate text-orange-400 mr-1"></i> Bollino</button>
                </div>
                
                <hr class="border-gray-700 my-1">

                <div id="textInspector" class="hidden space-y-2 animate-fade-in bg-gray-900/50 p-2 rounded border border-gray-600">
                    <div class="flex justify-between items-center mb-1">
                        <p class="text-[9px] text-yellow-500 font-bold uppercase"><i class="fa-solid fa-sliders mr-1"></i> Modifica</p>
                        <button id="aiStyleBtn" class="bg-gradient-to-r from-purple-600 to-blue-600 text-white text-[9px] px-1.5 py-0.5 rounded shadow flex items-center gap-1"><i class="fa-solid fa-wand-magic-sparkles"></i> AI</button>
                    </div>
                    
                    <div id="textSpecificControls" class="hidden">
                        <input type="text" id="selectedTextInput" class="w-full bg-gray-800 border border-gray-600 rounded p-1 text-xs text-white focus:border-yellow-500 outline-none mb-1">
                        <select id="fontSelector" class="w-full bg-gray-800 border border-gray-600 rounded p-1 text-[10px] text-white mb-1">
                            <optgroup label="Serif"><option value="'Cinzel', serif">Cinzel</option><option value="'Playfair Display', serif">Playfair</option><option value="'Merriweather', serif">Merriweather</option></optgroup>
                            <optgroup label="Sans"><option value="'Inter', sans-serif">Inter</option><option value="'Montserrat', sans-serif">Montserrat</option><option value="'Roboto', sans-serif">Roboto</option></optgroup>
                            <optgroup label="Display"><option value="'Bebas Neue', cursive">Bebas Neue</option><option value="'Anton', sans-serif">Anton</option><option value="'Creepster', cursive">Creepster</option></optgroup>
                        </select>
                        
                        <div class="flex gap-1 mb-1">
                             <button id="boldBtn" class="style-btn flex-1 bg-gray-800 border border-gray-600 rounded p-0.5 text-[10px] text-white"><i class="fa-solid fa-bold"></i></button>
                             <button id="italicBtn" class="style-btn flex-1 bg-gray-800 border border-gray-600 rounded p-0.5 text-[10px] text-white"><i class="fa-solid fa-italic"></i></button>
                             <button id="alignLeftBtn" class="style-btn flex-1 bg-gray-800 border border-gray-600 rounded p-0.5 text-[10px] text-white"><i class="fa-solid fa-align-left"></i></button>
                             <button id="alignCenterBtn" class="style-btn flex-1 bg-gray-800 border border-gray-600 rounded p-0.5 text-[10px] text-white"><i class="fa-solid fa-align-center"></i></button>
                             <button id="alignRightBtn" class="style-btn flex-1 bg-gray-800 border border-gray-600 rounded p-0.5 text-[10px] text-white"><i class="fa-solid fa-align-right"></i></button>
                        </div>
                    </div>

                    <div id="shapeSpecificControls" class="hidden">
                        <div class="flex items-center justify-between mb-0.5"><label class="text-[9px] text-gray-400">W/H</label></div>
                        <div class="flex gap-1 mb-1">
                            <input type="range" id="shapeWidthInput" min="10" max="500" step="5" value="100" class="flex-1">
                            <input type="range" id="shapeHeightInput" min="10" max="500" step="5" value="100" class="flex-1">
                        </div>
                        <div id="borderRadiusControl" class="mb-1">
                             <div class="flex items-center justify-between"><label class="text-[9px] text-gray-400">Radius</label></div>
                             <input type="range" id="shapeRadiusInput" min="0" max="100" step="1" value="0" class="w-full">
                        </div>
                    </div>

                    <div class="flex items-center justify-between mb-1">
                        <label class="text-[9px] text-gray-400 font-bold">Colore</label>
                        <input type="color" id="colorPicker" class="w-5 h-5 rounded cursor-pointer bg-transparent border-0 p-0" value="#ffffff">
                    </div>
                    
                    <div id="opacityControl" class="mb-1 hidden">
                         <div class="flex justify-between"><label class="text-[9px] text-gray-400">Opacità</label><span id="opacityValue" class="text-[9px] text-gray-400">100%</span></div>
                         <input type="range" id="opacityInput" min="0" max="1" step="0.1" value="1" class="w-full">
                    </div>

                    <div id="textSizeControl" class="mb-1 hidden">
                         <div class="flex justify-between"><label class="text-[9px] text-gray-400">Size</label><span id="sizeValueDisplay" class="text-[9px] text-gray-400">30px</span></div>
                         <input type="range" id="sizeInput" min="5" max="200" step="1" value="30" class="w-full">
                    </div>

                    <div id="textSpacingControl" class="mb-1 hidden"><div class="flex justify-between"><label class="text-[9px] text-gray-400">Space</label><span id="spacingValue" class="text-[9px] text-gray-400">0px</span></div><input type="range" id="spacingInput" min="-10" max="50" step="0.5" value="0" class="w-full"></div>
                    
                    <div class="space-y-1 pt-1 border-t border-gray-700">
                        <div id="textStrokeControl" class="hidden"><div class="flex justify-between items-center"><label class="text-[9px] text-gray-400">Stroke</label><input type="color" id="strokeColorPicker" class="w-4 h-4 rounded bg-transparent border-0 p-0" value="#000000"></div><input type="range" id="strokeWidthInput" min="0" max="5" step="0.1" value="0" class="w-full"></div>
                        
                        <div><div class="flex justify-between items-center"><label class="text-[9px] text-gray-400">Shadow</label><input type="color" id="shadowColorPicker" class="w-4 h-4 rounded bg-transparent border-0 p-0" value="#000000"></div><div class="flex gap-1"><input type="range" id="shadowBlurInput" min="0" max="20" class="flex-1"><input type="range" id="shadowOffsetInput" min="0" max="50" class="flex-1"></div></div>
                        
                        <div>
                            <div class="flex justify-between mb-0.5"><label class="text-[9px] text-gray-400">Ruota</label><span id="rotationValue" class="text-[9px] text-gray-400">0°</span></div>
                            <div class="flex gap-1 items-center">
                                <input type="range" id="rotationInput" min="-180" max="180" step="1" value="0" class="flex-1">
                                <button id="resetRotationBtn" class="bg-gray-700 text-white px-1 rounded text-[8px]">0</button>
                                <button id="rotateNegative90Btn" class="bg-gray-700 text-white px-1 rounded text-[8px]">-90</button>
                            </div>
                        </div>
                        
                        <button id="centerElementBtn" class="w-full mt-1 bg-yellow-600 hover:bg-yellow-500 text-white text-[10px] py-1 rounded shadow">Centra</button>
                    </div>
                    <button id="deleteElementBtn" class="w-full mt-2 bg-red-900/50 hover:bg-red-900 text-red-200 text-[10px] py-1 rounded border border-red-800">Elimina</button>
                </div>
                
                <div id="inspectorPlaceholder" class="text-center py-2 text-gray-500 text-[10px] italic border border-dashed border-gray-700 rounded">Seleziona elemento</div>
            </div>

             <div id="exportSection" class="hidden bg-gray-800 p-4 rounded-lg border border-gray-700 border-l-4 border-l-green-500 flex-shrink-0">
                <h2 class="text-sm font-semibold mb-2 flex items-center gap-2">
                    <i class="fa-solid fa-file-export text-green-500"></i> 
                    <span class="bg-clip-text text-transparent bg-gradient-to-r from-green-400 to-emerald-600">3. Esporta</span>
                </h2>
                <button id="downloadKindleBtn" class="w-full bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white text-shadow-black font-bold py-1.5 px-4 rounded shadow flex items-center justify-center gap-2 text-xs">
                    <i class="fa-brands fa-amazon"></i> Scarica Kindle HD
                </button>
             </div>

            <div id="printSection" class="hidden bg-gray-800 p-4 rounded-lg border border-gray-700 border-l-4 border-l-orange-500 space-y-2 flex-shrink-0">
                <h2 class="text-sm font-semibold flex items-center gap-2">
                    <i class="fa-solid fa-print text-orange-400"></i> 
                    <span class="bg-clip-text text-transparent bg-gradient-to-r from-orange-400 to-yellow-500">4. Paperback (KDP)</span>
                </h2>
                
                <div class="grid grid-cols-2 gap-2">
                      <div>
                        <label class="text-[9px] text-gray-400 uppercase font-bold">Trim</label>
                        <select id="trimSizeInput" class="w-full bg-gray-900 border border-orange-200 rounded p-1 text-[10px] text-white focus:border-orange-500 outline-none">
                            <option value="5x8">5" x 8"</option>
                            <option value="6x9">6" x 9"</option>
                            <option value="8.5x11" selected>8.5" x 11"</option>
                        </select>
                      </div>
                      <div>
                        <label class="text-[9px] text-gray-400 uppercase font-bold">Pagine</label>
                        <input type="number" id="pageCountInput" value="100" min="24" class="w-full bg-gray-900 border border-orange-200 rounded p-1 text-[10px] text-white focus:border-orange-500 outline-none">
                      </div>
                </div>

                <div>
                      <label class="text-[9px] text-gray-400 uppercase font-bold">Carta</label>
                      <select id="paperTypeInput" class="w-full bg-gray-900 border border-orange-200 rounded p-1 text-[10px] text-white focus:border-orange-500 outline-none">
                          <option value="white">Bianca</option>
                          <option value="cream">Crema</option>
                          <option value="color">Colori</option>
                      </select>
                </div>
                
                <button id="initPaperbackBtn" class="w-full bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white text-shadow-black font-bold py-1.5 px-2 rounded shadow flex items-center justify-center gap-1 text-xs mb-1">
                    <i class="fa-solid fa-pen-ruler"></i> Crea Layout
                </button>

                <div class="mb-1">
                    <label class="cursor-pointer w-full bg-gradient-to-r from-yellow-200 to-yellow-400 hover:from-yellow-100 hover:to-yellow-300 text-gray-900 font-bold py-1 px-2 rounded shadow flex items-center justify-center gap-1 text-[10px] transition-colors">
                        <i class="fa-solid fa-upload"></i> Importa Fronte
                        <input type="file" id="importFrontInput" accept="image/*" class="hidden">
                    </label>
                </div>
                
                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <label class="text-[9px] text-gray-400 uppercase font-bold mb-0.5 block">Spina</label>
                        <input type="color" id="spineColorInput" class="w-full h-5 bg-gray-900 border border-gray-600 rounded cursor-pointer" value="#F59E0B">
                    </div>
                    <div>
                        <label class="text-[9px] text-gray-400 uppercase font-bold mb-0.5 block">Retro</label>
                        <input type="color" id="backColorInput" class="w-full h-5 bg-gray-900 border border-gray-600 rounded cursor-pointer" value="#1a202c">
                    </div>
                </div>

                <div class="p-1.5 bg-gray-900 rounded border border-orange-200 text-[9px] text-gray-400">
                    <div class="flex justify-between mb-0.5"><span>Dorso:</span> <span id="spineWidthDisplay" class="text-white font-bold">0.23"</span></div>
                    <div class="flex justify-between mb-0.5"><span>Px:</span> <span id="totalResDisplay" class="text-white font-bold">-</span></div>
                    <div class="flex justify-between items-center mt-1 pt-1 border-t border-gray-700">
                        <span>Barcode</span>
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="toggleBarcode" class="sr-only peer">
                            <div class="relative w-6 h-3.5 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-2.5 after:w-2.5 after:transition-all peer-checked:bg-orange-500"></div>
                        </label>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <span>Guide</span>
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="toggleGuides" class="sr-only peer">
                            <div class="relative w-6 h-3.5 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-2.5 after:w-2.5 after:transition-all peer-checked:bg-orange-500"></div>
                        </label>
                    </div>
                </div>

                <div id="spineTools" class="hidden space-y-1.5 pt-2 border-t border-gray-700">
                    <div class="flex gap-1">
                        <input type="text" id="spineTextInput" class="flex-1 bg-gray-900 border border-orange-200 rounded text-[10px] text-white px-1" placeholder="Testo Spina">
                        <button id="addSpineTextBtn" class="bg-gray-600 hover:bg-gray-500 text-white py-0.5 px-2 rounded text-[10px]"><i class="fa-solid fa-plus"></i></button>
                    </div>
                    <button id="centerSpineTextBtn" class="w-full bg-gray-600 hover:bg-gray-500 text-orange-200 py-0.5 rounded text-[9px]">Centra Spina</button>
                    
                    <div class="flex gap-1 mt-1">
                        <input type="text" id="backTextInput" class="flex-1 bg-gray-900 border border-orange-200 rounded text-[10px] text-white px-1" placeholder="Testo Retro">
                        <button id="addBackTextBtn" class="bg-gray-600 hover:bg-gray-500 text-white py-0.5 px-2 rounded text-[10px]"><i class="fa-solid fa-plus"></i></button>
                    </div>
                    <button id="centerBackTextBtn" class="w-full bg-gray-600 hover:bg-gray-500 text-orange-200 py-0.5 rounded text-[9px]">Centra Retro</button>
                </div>

                <div id="paperbackTools" class="hidden space-y-1.5 pt-2 border-t border-gray-700">
                    <div class="grid grid-cols-1 gap-1">
                        <label class="cursor-pointer bg-orange-200 hover:bg-orange-300 text-gray-900 py-1 rounded text-[10px] flex items-center justify-center border border-gray-600">
                            <i class="fa-solid fa-image mr-1"></i> Immagine Extra
                            <input type="file" id="addBackImageInput" accept="image/*" class="hidden">
                        </label>
                    </div>

                    <div id="imageInspector" class="hidden space-y-1 bg-gray-900/50 p-1.5 rounded border border-gray-600 mt-1">
                        <p class="text-[9px] text-yellow-500 font-bold uppercase mb-1">Modifica Immagine</p>
                        <div class="flex gap-1 items-center"><span class="text-[9px] text-gray-400 w-6">Size</span><input type="range" id="imgSizeInput" min="10" max="800" step="5" value="150" class="flex-1"></div>
                        <div class="flex gap-1 items-center"><span class="text-[9px] text-gray-400 w-6">Rot</span><input type="range" id="imgRotationInput" min="-180" max="180" step="1" value="0" class="flex-1"></div>
                        <button id="deleteImageBtn" class="w-full mt-1 bg-red-900/50 hover:bg-red-900 text-red-200 text-[9px] py-0.5 rounded border border-red-800">Elimina</button>
                    </div>
                </div>
                
                <button id="downloadPrintBtn" class="w-full bg-gradient-to-r from-red-500 to-orange-400 hover:from-red-400 hover:to-orange-300 text-white text-shadow-strong font-bold py-1.5 px-4 rounded shadow flex items-center justify-center gap-2 text-xs mt-1 hidden transition-all duration-200 transform hover:scale-105">
                    <i class="fa-solid fa-download"></i> Scarica 300DPI
                </button>
            </div>
        </div>

        <div class="flex-1 flex flex-col gap-3 h-full min-w-0 pb-16">
            <div id="previewContainer" class="bg-gray-800 rounded-xl shadow-2xl border border-gray-700 flex flex-col items-center justify-center relative overflow-hidden p-2 flex-1 w-full">
                <div id="loader" class="hidden absolute inset-0 bg-gray-900/90 z-50 flex flex-col items-center justify-center backdrop-blur-sm">
                    <div class="banana-loader mb-4"></div><p id="loaderText" class="text-yellow-400 font-mono animate-pulse">la tua cover è in arrivo..........</p>
                </div>
                <div id="placeholder" class="text-gray-600 text-center"><i class="fa-solid fa-palette text-6xl mb-4 opacity-20"></i><p>Configura lo stile a sinistra e genera la base.</p></div>
                <div id="interactiveArea" class="hidden shadow-2xl relative bg-black">
                    <div id="guidesOverlay" class="absolute inset-0 pointer-events-none hidden"></div>
                    <div id="selectionBox" style="display:none;"></div>
                </div>
                <div id="barcodeArea" class="hidden flex flex-col items-center justify-center">
                    <div id="barcodeLines"></div>
                    <div id="barcodeText">ISBN 978-0-00-000000-0</div>
                </div>
            </div>
            
            <div id="infoBar" class="h-8 bg-gray-800 rounded-lg border border-gray-700 flex items-center justify-between px-3 flex-shrink-0 shadow-lg">
                 <div id="canvasDimensionsDisplay" class="text-[10px] text-orange-200 font-mono hidden flex items-center"><i class="fa-solid fa-ruler-combined mr-2"></i><span>-</span></div>
                 <div id="canvasInfo" class="hidden text-[10px] text-gray-400 flex items-center gap-2 ml-auto"><i class="fa-solid fa-mouse-pointer text-yellow-500"></i><span>Clicca e trascina i testi.</span></div>
            </div>
            
            <canvas id="exportCanvas" class="hidden"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURAZIONE ---
            const NANO_BANANA_API_KEY = "YOUR_PROFESSIONAL_KEY_HERE"; 
            const NANO_BANANA_ENDPOINT = "https://api.nanobanana.com/v1/generate"; 
            const stripe = Stripe('pk_test_YOUR_STRIPE_PUBLIC_KEY'); 

            // --- STATO ---
            const state = { 
                mode: 'kindle', 
                generatedImageB64: null, 
                originalImageB64: null, 
                printFrontImage: null, 
                styleReferenceB64: null,
                elements: [], 
                selectedElementId: null, 
                idCounter: 0, 
                canvasScale: 1, 
                paperbackLayout: null,
                pickingColor: null,
                isSelectingArea: false,
                selectionStart: { x: 0, y: 0 },
                selectionRect: null,
                lastActiveMode: 'kindle'
            };
            
            // --- RIFERIMENTI DOM ---
            const els = {
                titleInput: document.getElementById('titleInput'), 
                mood: document.getElementById('mood'),
                styleGenre: document.getElementById('styleGenre'),
                runAgentsBtn: document.getElementById('runAgentsBtn'),
                modificationArea: document.getElementById('modificationArea'),
                modificationPrompt: document.getElementById('modificationPrompt'),
                modifyArtworkBtn: document.getElementById('modifyArtworkBtn'),
                undoBtn: document.getElementById('undoBtn'),
                styleRefInput: document.getElementById('styleRefInput'), 
                styleRefPreview: document.getElementById('styleRefPreview'), 
                styleRefImg: document.getElementById('styleRefImg'), 
                clearStyleRef: document.getElementById('clearStyleRef'), 
                designStudio: document.getElementById('designStudio'),
                exportSection: document.getElementById('exportSection'),
                printSection: document.getElementById('printSection'), 
                initPaperbackBtn: document.getElementById('initPaperbackBtn'),
                paperbackTools: document.getElementById('paperbackTools'),
                spineTools: document.getElementById('spineTools'), 
                spineTextInput: document.getElementById('spineTextInput'), 
                addSpineTextBtn: document.getElementById('addSpineTextBtn'), 
                centerSpineTextBtn: document.getElementById('centerSpineTextBtn'), 
                addBackTextBtn: document.getElementById('addBackTextBtn'),
                backTextInput: document.getElementById('backTextInput'), 
                centerBackTextBtn: document.getElementById('centerBackTextBtn'), 
                addBackImageInput: document.getElementById('addBackImageInput'),
                downloadPrintBtn: document.getElementById('downloadPrintBtn'),
                trimSizeInput: document.getElementById('trimSizeInput'),
                pageCountInput: document.getElementById('pageCountInput'),
                paperTypeInput: document.getElementById('paperTypeInput'), 
                spineColorInput: document.getElementById('spineColorInput'),
                backColorInput: document.getElementById('backColorInput'),
                spineWidthDisplay: document.getElementById('spineWidthDisplay'),
                totalResDisplay: document.getElementById('totalResDisplay'), 
                canvasDimensionsDisplay: document.getElementById('canvasDimensionsDisplay'), 
                addGenericTextBtn: document.getElementById('addGenericTextBtn'),
                textInspector: document.getElementById('textInspector'),
                imageInspector: document.getElementById('imageInspector'), 
                inspectorPlaceholder: document.getElementById('inspectorPlaceholder'),
                selectedTextInput: document.getElementById('selectedTextInput'),
                fontSelector: document.getElementById('fontSelector'),
                colorPicker: document.getElementById('colorPicker'),
                sizeInput: document.getElementById('sizeInput'),
                textSizeControl: document.getElementById('textSizeControl'),
                textStrokeControl: document.getElementById('textStrokeControl'),
                textSpacingControl: document.getElementById('textSpacingControl'),
                shapeSpecificControls: document.getElementById('shapeSpecificControls'),
                shapeWidthInput: document.getElementById('shapeWidthInput'),
                shapeHeightInput: document.getElementById('shapeHeightInput'),
                shapeWidthDisplay: document.getElementById('shapeWidthDisplay'),
                shapeHeightDisplay: document.getElementById('shapeHeightDisplay'),
                shapeRadiusInput: document.getElementById('shapeRadiusInput'),
                shapeRadiusDisplay: document.getElementById('shapeRadiusDisplay'),
                borderRadiusControl: document.getElementById('borderRadiusControl'),
                spacingInput: document.getElementById('spacingInput'),
                spacingValue: document.getElementById('spacingValue'),
                strokeColorPicker: document.getElementById('strokeColorPicker'),
                strokeWidthInput: document.getElementById('strokeWidthInput'),
                shadowColorPicker: document.getElementById('shadowColorPicker'),
                shadowBlurInput: document.getElementById('shadowBlurInput'),
                shadowOffsetInput: document.getElementById('shadowOffsetInput'), 
                shadowAngleInput: document.getElementById('shadowAngleInput'), 
                angleValue: document.getElementById('angleValue'),
                offsetValue: document.getElementById('offsetValue'),
                rotationInput: document.getElementById('rotationInput'),
                rotationValue: document.getElementById('rotationValue'),
                imgSizeInput: document.getElementById('imgSizeInput'), 
                imgSizeValue: document.getElementById('imgSizeValue'), 
                imgRotationInput: document.getElementById('imgRotationInput'), 
                imgRotationValue: document.getElementById('imgRotationValue'), 
                deleteImageBtn: document.getElementById('deleteImageBtn'), 
                importFrontInput: document.getElementById('importFrontInput'),
                deleteElementBtn: document.getElementById('deleteElementBtn'),
                centerElementBtn: document.getElementById('centerElementBtn'),
                addRectBtn: document.getElementById('addRectBtn'),
                addCircleBtn: document.getElementById('addCircleBtn'),
                addBadgeBtn: document.getElementById('addBadgeBtn'),
                addFlagBtn: document.getElementById('addFlagBtn'),
                addBulletBtn: document.getElementById('addBulletBtn'),
                opacityControl: document.getElementById('opacityControl'),
                opacityInput: document.getElementById('opacityInput'),
                opacityValue: document.getElementById('opacityValue'),
                aiStyleBtn: document.getElementById('aiStyleBtn'),
                downloadKindleBtn: document.getElementById('downloadKindleBtn'),
                interactiveArea: document.getElementById('interactiveArea'),
                placeholder: document.getElementById('placeholder'),
                loader: document.getElementById('loader'),
                loaderText: document.getElementById('loaderText'),
                canvasInfo: document.getElementById('canvasInfo'),
                boldBtn: document.getElementById('boldBtn'),
                italicBtn: document.getElementById('italicBtn'),
                sizeValueDisplay: document.getElementById('sizeValueDisplay'),
                textSpecificControls: document.getElementById('textSpecificControls'),
                resetRotationBtn: document.getElementById('resetRotationBtn'),
                rotateNegative90Btn: document.getElementById('rotateNegative90Btn'),
                toggleSelectModeBtn: document.getElementById('toggleSelectModeBtn'),
                selectionControls: document.getElementById('selectionControls'),
                selectionBox: document.getElementById('selectionBox'), 
                selectivePrompt: document.getElementById('selectivePrompt'),
                applySelectiveBtn: document.getElementById('applySelectiveBtn'),
                cancelSelectBtn: document.getElementById('cancelSelectBtn'),
                toggleBarcode: document.getElementById('toggleBarcode'),
                toggleGuides: document.getElementById('toggleGuides'),
                barcodeArea: document.getElementById('barcodeArea'),
                guidesOverlay: document.getElementById('guidesOverlay'),
                exportCanvas: document.getElementById('exportCanvas'),
                previewContainer: document.getElementById('previewContainer'),
                alignLeftBtn: document.getElementById('alignLeftBtn'),
                alignCenterBtn: document.getElementById('alignCenterBtn'),
                alignRightBtn: document.getElementById('alignRightBtn'),
                resetBtn: document.getElementById('resetBtn')
            };

            // --- LOGICA FUNZIONALE (INTATTA) ---
            
            function rgbToHex(r, g, b) {
                if (r > 255 || g > 255 || b > 255) throw "Invalid color component";
                return ((r << 16) | (g << 8) | b).toString(16);
            }
            
            function performReset() {
                 if(!confirm('Sei sicuro di voler resettare tutto e ricominciare da zero?')) return;
                 
                 state.mode = 'kindle';
                 state.generatedImageB64 = null;
                 state.originalImageB64 = null;
                 state.printFrontImage = null;
                 state.styleReferenceB64 = null;
                 state.elements = [];
                 state.selectedElementId = null;
                 state.idCounter = 0;
                 state.canvasScale = 1;
                 state.paperbackLayout = null;
                 state.lastActiveMode = 'kindle';
                 state.isSelectingArea = false;
                 state.selectionRect = null;
                 
                 if(els.titleInput) els.titleInput.value = '';
                 if(els.mood) els.mood.value = '';
                 if(els.styleGenre) els.styleGenre.value = 'none';
                 if(els.modificationPrompt) els.modificationPrompt.value = '';
                 if(els.selectedTextInput) els.selectedTextInput.value = '';
                 if(els.spineTextInput) els.spineTextInput.value = '';
                 if(els.backTextInput) els.backTextInput.value = '';
                 if(els.styleRefInput) els.styleRefInput.value = '';
                 if(els.importFrontInput) els.importFrontInput.value = '';
                 if(els.addBackImageInput) els.addBackImageInput.value = '';
                 
                 if(els.toggleBarcode) els.toggleBarcode.checked = false;
                 if(els.toggleGuides) els.toggleGuides.checked = false;
                 
                 if(els.interactiveArea) {
                    els.interactiveArea.innerHTML = ''; 
                    els.interactiveArea.style.backgroundImage = '';
                    els.interactiveArea.classList.add('hidden');
                    els.interactiveArea.appendChild(els.guidesOverlay);
                    els.interactiveArea.appendChild(els.barcodeArea);
                    els.interactiveArea.appendChild(els.selectionBox);
                 }
                 if(els.placeholder) els.placeholder.classList.remove('hidden');
                 
                 if(els.modificationArea) els.modificationArea.classList.add('hidden');
                 if(els.designStudio) els.designStudio.classList.add('hidden');
                 if(els.printSection) els.printSection.classList.add('hidden');
                 if(els.exportSection) els.exportSection.classList.add('hidden');
                 if(els.textInspector) els.textInspector.classList.add('hidden');
                 if(els.imageInspector) els.imageInspector.classList.add('hidden');
                 if(els.inspectorPlaceholder) els.inspectorPlaceholder.classList.remove('hidden');
                 if(els.paperbackTools) els.paperbackTools.classList.add('hidden');
                 if(els.spineTools) els.spineTools.classList.add('hidden');
                 if(els.downloadPrintBtn) els.downloadPrintBtn.classList.add('hidden');
                 if(els.canvasDimensionsDisplay) els.canvasDimensionsDisplay.classList.add('hidden');
                 if(els.guidesOverlay) els.guidesOverlay.classList.add('hidden');
                 if(els.barcodeArea) els.barcodeArea.classList.add('hidden');
                 if(els.selectionBox) els.selectionBox.style.display = 'none';
                 if(els.styleRefPreview) els.styleRefPreview.classList.add('hidden');
                 if(els.clearStyleRef) els.clearStyleRef.classList.add('hidden');
                 if(els.canvasInfo) els.canvasInfo.classList.add('hidden');
                 
                 if(els.toggleSelectModeBtn) {
                    els.toggleSelectModeBtn.innerHTML = '<i class="fa-regular fa-square"></i> Definisci Area';
                    els.toggleSelectModeBtn.className = 'w-full bg-pink-500 hover:bg-pink-400 text-white text-shadow-black text-xs py-2 rounded shadow transition-colors flex items-center justify-center gap-2 font-bold mb-2';
                 }
            }

            async function applyAiStyle() {
                alert("Configura la API Key Google Gemini nel codice per usare questa funzione.");
            }

            function updateShadow() {
                const el = state.elements.find(e => e.id === state.selectedElementId);
                const domEl = document.getElementById(state.selectedElementId);
                if(el && domEl) {
                    const c = els.shadowColorPicker.value;
                    const b = els.shadowBlurInput.value;
                    const o = els.shadowOffsetInput.value;
                    const a = els.shadowAngleInput.value || 45;
                    const rad = a * (Math.PI / 180);
                    const x = (o * Math.cos(rad)).toFixed(1);
                    const y = (o * Math.sin(rad)).toFixed(1);
                    const shadowVal = b > 0 || o > 0 ? `${x}px ${y}px ${b}px ${c}` : 'none';
                    if (el.type === 'text') { el.style.textShadow = shadowVal; domEl.style.textShadow = shadowVal; } 
                    else if (el.type === 'shape') { el.style.boxShadow = b > 0 || o > 0 ? `${x}px ${y}px ${b}px ${c}` : 'none'; domEl.style.boxShadow = el.style.boxShadow; }
                    el.shadowProps = { color: c, blur: b, offset: o, angle: a };
                }
            }
            
            function updateAlignment(align) {
                if(!state.selectedElementId) return;
                const el = state.elements.find(e => e.id === state.selectedElementId);
                if(el && el.type === 'text') {
                    el.style.textAlign = align;
                    const domEl = document.getElementById(state.selectedElementId);
                    if(domEl) domEl.style.textAlign = align;
                    els.alignLeftBtn.classList.toggle('active', align === 'left');
                    els.alignCenterBtn.classList.toggle('active', align === 'center');
                    els.alignRightBtn.classList.toggle('active', align === 'right');
                }
            }

            function updatePrintCalculations() {
                const [w, h] = els.trimSizeInput.value.split('x').map(parseFloat);
                const pages = parseInt(els.pageCountInput.value) || 100;
                const paperType = els.paperTypeInput.value;

                let paperThickness = 0.002252; // White (Standard)
                if (paperType === 'cream') paperThickness = 0.0025;
                else if (paperType === 'color') paperThickness = 0.002347;

                const spine = pages * paperThickness; 
                const bleed = 0.125; 
                
                const totalW_inch = bleed + w + spine + w + bleed;
                const totalH_inch = bleed + h + bleed;
                
                const dpi = 300;
                const pxW = Math.ceil(totalW_inch * dpi);
                const pxH = Math.ceil(totalH_inch * dpi);
                
                els.spineWidthDisplay.innerText = `${spine.toFixed(3)}"`;
                if(els.totalResDisplay) els.totalResDisplay.innerText = `${pxW} x ${pxH} px`;
                
                if(state.mode === 'paperback') {
                    els.canvasDimensionsDisplay.innerHTML = `<i class="fa-solid fa-ruler-combined mr-2"></i>DIMENSIONE TOTALE FILE: <b>${pxW} x ${pxH} px</b> (300 DPI)`;
                }

                return { pxW, pxH, frontPx: w*dpi, spinePx: spine*dpi, bleedPx: bleed*dpi, trimW: w, trimH: h, spineInch: spine };
            }

            function initKindleCanvas() {
                state.mode = 'kindle';
                state.isSelectingArea = false;
                els.selectionBox.style.display = 'none';
                els.selectionControls.classList.add('hidden');
                els.toggleSelectModeBtn.innerHTML = '<i class="fa-regular fa-square"></i> Definisci Area';
                els.toggleSelectModeBtn.className = 'w-full bg-pink-500 hover:bg-pink-400 text-white text-shadow-black text-xs py-2 rounded shadow transition-colors flex items-center justify-center gap-2 font-bold mb-2';

                els.interactiveArea.style.width = '400px';
                els.interactiveArea.style.height = '517.65px'; 
                els.interactiveArea.style.backgroundImage = `url(${state.generatedImageB64})`;
                els.interactiveArea.style.backgroundSize = 'cover';
                els.interactiveArea.style.backgroundPosition = 'center';
                els.interactiveArea.style.backgroundRepeat = 'no-repeat';
                els.placeholder.classList.add('hidden');
                els.interactiveArea.classList.remove('hidden');
                els.canvasInfo.classList.remove('hidden');
                els.paperbackTools.classList.add('hidden');
                els.spineTools.classList.add('hidden'); 
                els.downloadPrintBtn.classList.add('hidden');
                els.canvasDimensionsDisplay.classList.add('hidden'); 
                
                if(els.barcodeArea.parentNode) els.barcodeArea.remove(); 
                els.barcodeArea.classList.add('hidden'); 

                els.interactiveArea.innerHTML = '';
                els.interactiveArea.appendChild(els.guidesOverlay); 
                els.guidesOverlay.classList.add('hidden'); 
                els.interactiveArea.appendChild(els.selectionBox); 
                
                state.elements.forEach(el => renderElementDOM(el));
            }

            function initPaperbackMode() {
                if(!state.generatedImageB64 && !state.printFrontImage) return alert("Genera prima la copertina o importa un'immagine!");
                
                const wasKindle = (state.mode === 'kindle');
                state.mode = 'paperback';
                state.isSelectingArea = false;
                els.selectionBox.style.display = 'none'; 
                els.selectionControls.classList.add('hidden');
                els.toggleSelectModeBtn.innerHTML = '<i class="fa-regular fa-square"></i> Definisci Area';
                els.toggleSelectModeBtn.className = 'w-full bg-pink-500 hover:bg-pink-400 text-white text-shadow-black text-xs py-2 rounded shadow transition-colors flex items-center justify-center gap-2 font-bold mb-2';

                const calc = updatePrintCalculations();
                const ratio = calc.pxW / calc.pxH;
                
                // --- FIX LOGIC: FIT TO SCREEN (SCALE TO FIT) ---
                // Calcola l'altezza disponibile reale nel contenitore padre, sottraendo padding e status bar
                const maxW = els.previewContainer.clientWidth - 16;
                const maxH = els.previewContainer.clientHeight - 16; 

                // 1. Calcola larghezza ipotetica basata sul contenitore
                let viewW = maxW;
                let viewH = viewW / ratio;

                // 2. Se l'altezza supera il limite visibile, ridimensiona basandosi sull'altezza
                if (viewH > maxH) {
                    viewH = maxH;
                    viewW = viewH * ratio;
                }
                // --- END FIX ---
                
                els.interactiveArea.style.width = viewW + 'px';
                els.interactiveArea.style.height = viewH + 'px';
                
                els.canvasDimensionsDisplay.classList.remove('hidden');
                els.canvasDimensionsDisplay.innerHTML = `<i class="fa-solid fa-ruler-combined mr-2"></i>DIMENSIONE TOTALE FILE: <b>${calc.pxW} x ${calc.pxH} px</b> (300 DPI)`;
                
                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = calc.pxW; bgCanvas.height = calc.pxH;
                const ctx = bgCanvas.getContext('2d');
                
                const frontImg = new Image();
                frontImg.onload = () => {
                    ctx.fillStyle = els.backColorInput.value; 
                    ctx.fillRect(0,0, calc.pxW, calc.pxH);
                    
                    ctx.fillStyle = els.spineColorInput.value;
                    const backCoverWidth = calc.bleedPx + calc.frontPx; 
                    ctx.fillRect(backCoverWidth, 0, calc.spinePx, calc.pxH);

                    const fx = backCoverWidth + calc.spinePx;
                    let dW, dH, dX, dY;
                    const fw = calc.frontPx + calc.bleedPx; 
                    const fh = calc.pxH; 

                    const imgR = frontImg.width / frontImg.height;
                    const targetR = fw / fh;
                    
                    if (imgR > targetR) { dH = fh; dW = fh * imgR; dX = fx + (fw - dW)/2; dY = 0; } 
                    else { dW = fw; dH = fw / imgR; dX = fx; dY = (fh - dH)/2; }
                    
                    ctx.save(); ctx.beginPath(); ctx.rect(fx, 0, fw, fh); ctx.clip();
                    ctx.drawImage(frontImg, 0, 0, frontImg.width, frontImg.height, dX, dY, dW, dH);
                    ctx.restore();
                    
                    els.interactiveArea.style.backgroundImage = `url(${bgCanvas.toDataURL()})`;
                    els.interactiveArea.style.backgroundSize = 'contain';
                };
                frontImg.src = state.printFrontImage || state.generatedImageB64;
                
                els.interactiveArea.innerHTML = '';
                els.interactiveArea.appendChild(els.guidesOverlay); 
                els.interactiveArea.appendChild(els.barcodeArea); 
                els.interactiveArea.appendChild(els.selectionBox); 
                
                els.guidesOverlay.classList.add('hidden');
                els.barcodeArea.classList.add('hidden');
                
                if(els.toggleBarcode.checked) els.barcodeArea.classList.remove('hidden');
                if(els.toggleGuides.checked) {
                    drawKDPGuides(calc, viewW, viewH);
                    els.guidesOverlay.classList.remove('hidden');
                }

                // *** BARCODE POSITION LOGIC ***
                const scale = viewW / calc.pxW;
                const marginInch = 0.35; 
                const backCoverPanelWidth = calc.bleedPx + calc.frontPx; 
                const visualBackEnd = backCoverPanelWidth * scale;
                const visualBarcodeLeft = visualBackEnd - 100; // 90px width + 10px padding
                const visualBottom = viewH - (calc.bleedPx * scale) - 70; // 55px height + 15px padding
                
                els.barcodeArea.style.left = visualBarcodeLeft + 'px';
                els.barcodeArea.style.top = visualBottom + 'px';

                els.paperbackTools.classList.remove('hidden');
                els.spineTools.classList.remove('hidden'); 
                els.downloadPrintBtn.classList.remove('hidden');
                state.paperbackLayout = calc;
                state.canvasScale = scale;
                
                if (wasKindle) {
                    const kindleWidth = 400;
                    const frontCoverVisualWidth = (calc.frontPx + calc.bleedPx) * scale;
                    const frontCoverStartX = (calc.bleedPx + calc.frontPx + calc.spinePx) * scale;
                    const elementScale = frontCoverVisualWidth / kindleWidth;
                    
                    state.elements.forEach(el => {
                        el.x = (el.x * elementScale) + frontCoverStartX;
                        el.y = (el.y * elementScale);
                        let fSize = parseFloat(el.style.fontSize);
                        el.style.fontSize = (fSize * elementScale) + 'px';
                        if(el.type === 'shape' || el.type === 'image') {
                            el.width = el.width * elementScale;
                            if(el.height) el.height = el.height * elementScale;
                        }
                    });
                }
                
                state.elements.forEach(el => renderElementDOM(el));

                setTimeout(() => {
                    els.spineTools.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }

            function drawKDPGuides(calc, viewW, viewH) {
                const guideContainer = els.guidesOverlay;
                guideContainer.innerHTML = '';
                
                const scale = viewW / calc.pxW;
                const bleed = calc.bleedPx * scale;
                const safe = (0.25 * 300) * scale;
                const spineStart = (calc.bleedPx + calc.frontPx) * scale;
                const spineWidth = calc.spinePx * scale;
                
                const trimBox = document.createElement('div');
                trimBox.className = 'kdp-trim-line';
                trimBox.style.left = bleed + 'px'; trimBox.style.top = bleed + 'px';
                trimBox.style.width = (viewW - (bleed * 2)) + 'px'; trimBox.style.height = (viewH - (bleed * 2)) + 'px';
                guideContainer.appendChild(trimBox);
                
                const topBleed = document.createElement('div'); topBleed.className = 'kdp-bleed-zone';
                topBleed.style.top = '0'; topBleed.style.left = '0'; topBleed.style.width = '100%'; topBleed.style.height = bleed + 'px';
                guideContainer.appendChild(topBleed);
                
                const botBleed = document.createElement('div'); botBleed.className = 'kdp-bleed-zone';
                botBleed.style.bottom = '0'; botBleed.style.left = '0'; botBleed.style.width = '100%'; botBleed.style.height = bleed + 'px';
                guideContainer.appendChild(botBleed);
                
                const leftBleed = document.createElement('div'); leftBleed.className = 'kdp-bleed-zone';
                leftBleed.style.top = bleed+'px'; leftBleed.style.left = '0'; leftBleed.style.width = bleed + 'px'; leftBleed.style.height = (viewH - bleed*2) + 'px';
                guideContainer.appendChild(leftBleed);
                
                const rightBleed = document.createElement('div'); rightBleed.className = 'kdp-bleed-zone';
                rightBleed.style.top = bleed+'px'; rightBleed.style.right = '0'; rightBleed.style.width = bleed + 'px'; rightBleed.style.height = (viewH - bleed*2) + 'px';
                guideContainer.appendChild(rightBleed);

                const spineFold = document.createElement('div');
                spineFold.className = 'kdp-spine-fold';
                spineFold.style.left = spineStart + 'px'; spineFold.style.top = '0px'; spineFold.style.width = spineWidth + 'px';
                guideContainer.appendChild(spineFold);

                const backSafe = document.createElement('div');
                backSafe.className = 'kdp-safe-zone';
                backSafe.style.left = (bleed + safe) + 'px'; backSafe.style.top = (bleed + safe) + 'px';
                const spineSafeMargin = (0.0625 * 300) * scale;
                backSafe.style.width = (spineStart - (bleed + safe) - spineSafeMargin) + 'px';
                backSafe.style.height = (viewH - (bleed * 2) - (safe * 2)) + 'px';
                guideContainer.appendChild(backSafe);

                const frontSafe = document.createElement('div');
                frontSafe.className = 'kdp-safe-zone';
                frontSafe.style.left = (spineStart + spineWidth + spineSafeMargin) + 'px';
                frontSafe.style.top = (bleed + safe) + 'px';
                frontSafe.style.width = (viewW - (spineStart + spineWidth) - (bleed + safe) - spineSafeMargin) + 'px';
                frontSafe.style.height = (viewH - (bleed * 2) - (safe * 2)) + 'px';
                guideContainer.appendChild(frontSafe);
            }

            function addElement(type, content) {
                 const id = `el_${state.idCounter++}`;
                let el = { 
                    id, type, content, x: 50, y: 50, rotation: 0,
                    style: { color: '#ffffff', fontSize: 30, fontFamily: "'Inter', sans-serif", fontWeight: 'normal', fontStyle: 'normal', letterSpacing: '0px', webkitTextStrokeColor: '#000000', webkitTextStrokeWidth: '0px', textShadow: 'none', opacity: 1, textAlign: 'center' }, 
                    shadowProps: { color: '#000000', blur: 0, offset: 0, angle: 45 }
                };
                if(type === 'image') { el.width = 150; el.src = content; }
                else if (type === 'shape') { 
                    el.width = 100; el.height = 100; el.shapeType = content; el.style.color = '#F59E0B'; el.borderRadius = 0;
                }
                
                state.elements.push(el); renderElementDOM(el); selectElement(id);
                return id; 
            }
            
            function addSpineText() {
                 if(state.mode !== 'paperback') return alert("Passa prima al formato Paperback!");
                 let text = els.spineTextInput.value;
                 if(!text) text = "TESTO SPINA"; 
                 
                 const id = addElement('text', text); 
                 
                 const el = state.elements.find(e => e.id === id);
                 const domEl = document.getElementById(id);
                 
                 if(el && domEl) {
                     el.style.fontSize = 12; el.style.fontWeight = 'normal'; domEl.style.fontSize = '12px'; domEl.style.fontWeight = 'normal'; selectElement(id);
                 }
                 
                 const layout = state.paperbackLayout || updatePrintCalculations();
                 const viewW = parseFloat(els.interactiveArea.style.width);
                 const scale = viewW / layout.pxW;
                 const spineCenterX = (layout.bleedPx + layout.frontPx + (layout.spinePx / 2)) * scale;
                 const spineCenterY = (layout.pxH / 2) * scale;
                 
                 updateElementById(id, 'rotation', -90);
                 
                 setTimeout(() => {
                     const dom = document.getElementById(id);
                     if(dom) {
                        const w = dom.offsetWidth; const h = dom.offsetHeight; 
                        updateElementById(id, 'x', spineCenterX - (w/2));
                        updateElementById(id, 'y', spineCenterY - (h/2));
                     }
                     els.designStudio.classList.remove('hidden');
                     els.textInspector.classList.remove('hidden');
                     els.designStudio.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 }, 50);

                 els.spineTextInput.value = '';
            }
            
            function addBackText() {
                 if(state.mode !== 'paperback') return alert("Passa prima al formato Paperback!");
                 let text = els.backTextInput.value;
                 if(!text) text = "TESTO RETRO"; 
                 
                 const id = addElement('text', text);
                 setTimeout(() => {
                     centerBackText(); 
                     els.designStudio.classList.remove('hidden');
                     els.textInspector.classList.remove('hidden');
                     els.designStudio.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 }, 50);
                 els.backTextInput.value = '';
            }
            
            function centerSpineText() {
                if(!state.selectedElementId) return;
                const layout = updatePrintCalculations(); 
                const viewW = els.interactiveArea.clientWidth; 
                const scale = viewW / layout.pxW; 
                const spineCenterPx = layout.bleedPx + layout.frontPx + (layout.spinePx / 2);
                const spineCenterX = spineCenterPx * scale;
                const dom = document.getElementById(state.selectedElementId);
                if(!dom) return;
                const w = dom.offsetWidth;
                updateElementById(state.selectedElementId, 'x', spineCenterX - (w/2));
            }
            
            function centerBackText() {
                if(!state.selectedElementId) return;
                const layout = updatePrintCalculations(); 
                const viewW = els.interactiveArea.clientWidth; 
                const scale = viewW / layout.pxW; 
                const backCenterPx = layout.bleedPx + (layout.frontPx / 2); 
                const backCenterVisualX = backCenterPx * scale;
                const domEl = document.getElementById(state.selectedElementId);
                if (!domEl) return;
                const w = domEl.offsetWidth;
                updateElementById(state.selectedElementId, 'x', backCenterVisualX - (w/2));
            }

            function handleImageUpload(e) {
                const file = e.target.files[0];
                if(file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        addElement('image', evt.target.result);
                        setTimeout(() => {
                            if (!els.imageInspector.classList.contains('hidden')) {
                                els.imageInspector.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }, 100);
                    };
                    reader.readAsDataURL(file);
                }
            }

            function renderElementDOM(el) {
                const div = document.createElement('div');
                div.id = el.id;
                div.className = 'draggable-item';
                
                if(el.type === 'text') {
                    div.innerText = el.content || 'Testo';
                } else if (el.type === 'image') {
                    const img = document.createElement('img'); img.src = el.src; img.style.width = el.width + 'px'; div.appendChild(img);
                } else if (el.type === 'shape') {
                    div.style.width = el.width + 'px';
                    div.style.height = (el.height || el.width) + 'px'; 
                    
                    if (el.shapeType === 'triangle') {
                        div.style.backgroundColor = 'transparent'; div.style.width = '0'; div.style.height = '0'; 
                        div.style.borderLeft = (el.width/2) + 'px solid transparent';
                        div.style.borderRight = (el.width/2) + 'px solid transparent';
                        div.style.borderBottom = (el.height || el.width) + 'px solid ' + el.style.color;
                        div.style.borderRadius = '0';
                    } else if (el.shapeType === 'badge') {
                        div.style.backgroundColor = el.style.color;
                        const points = []; const spikes = 40; const outer = 50; const inner = 45; const cx = 50; const cy = 50;
                        for(let i=0; i<spikes*2; i++){
                            const r = (i%2 === 0) ? outer : inner;
                            const angle = (Math.PI * i) / spikes;
                            const x = cx + r * Math.cos(angle);
                            const y = cy + r * Math.sin(angle);
                            points.push(`${x.toFixed(1)}% ${y.toFixed(1)}%`);
                        }
                        div.style.clipPath = `polygon(${points.join(',')})`;
                        div.style.borderRadius = '0';
                    } else if (el.shapeType === 'flag') {
                        div.style.backgroundColor = el.style.color;
                        div.style.clipPath = 'polygon(0% 0%, 100% 0%, 80% 50%, 100% 100%, 0% 100%)';
                        div.style.borderRadius = '0';
                    } else if (el.shapeType === 'bullet') {
                        div.style.display = 'flex'; div.style.alignItems = 'center'; div.style.justifyContent = 'center'; 
                        const icon = document.createElement('div');
                        icon.style.width = '20px'; icon.style.height = '20px'; icon.style.borderRadius = '50%';
                        icon.style.backgroundColor = el.style.color; icon.style.flexShrink = '0';
                        icon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                        div.appendChild(icon);
                        div.style.backgroundColor = 'transparent';
                    } else {
                        div.style.backgroundColor = el.style.color;
                        if (el.shapeType === 'circle') div.style.borderRadius = '50%';
                        else if (el.shapeType === 'rect') div.style.borderRadius = (el.borderRadius || 0) + 'px';
                        else div.style.borderRadius = '0';
                    }
                }
                
                applyStyles(div, el);
                div.addEventListener('mousedown', startDrag);
                div.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    if(state.mode === 'selecting') return;
                    selectElement(el.id);
                    if(el.type === 'text' || el.type === 'shape') {
                        els.designStudio.classList.remove('hidden');
                        els.designStudio.scrollIntoView({behavior: 'smooth', block: 'center'});
                    }
                });
                els.interactiveArea.appendChild(div);
            }

            function applyStyles(div, el) {
                div.style.left = el.x + 'px'; div.style.top = el.y + 'px'; div.style.transform = `rotate(${el.rotation}deg)`; div.style.zIndex = 200; 
                div.style.opacity = el.style.opacity; 
                
                if(el.type === 'text') {
                    Object.assign(div.style, {
                        color: el.style.color, fontFamily: el.style.fontFamily, 
                        fontWeight: el.style.fontWeight, fontStyle: el.style.fontStyle, letterSpacing: el.style.letterSpacing, webkitTextStrokeColor: el.style.webkitTextStrokeColor, 
                        webkitTextStrokeWidth: el.style.webkitTextStrokeWidth, textShadow: el.style.textShadow, textAlign: el.style.textAlign
                    });
                    
                    let size = el.style.fontSize;
                    if (typeof size === 'string' && size.includes('px')) { div.style.fontSize = size; } 
                    else { div.style.fontSize = size + 'px'; }
                    div.innerText = el.content;
                } else if (el.type === 'image') {
                    const img = div.querySelector('img');
                    if(img) img.style.width = el.width + 'px';
                } else if (el.type === 'shape') {
                      const h = el.height || el.width;
                      div.style.boxShadow = el.style.boxShadow || 'none';

                      if (el.shapeType === 'triangle') {
                        div.style.borderBottomColor = el.style.color;
                        div.style.borderLeftWidth = (el.width/2) + 'px';
                        div.style.borderRightWidth = (el.width/2) + 'px';
                        div.style.borderBottomWidth = h + 'px';
                        div.style.boxShadow = 'none'; 
                      } else if (el.shapeType === 'badge' || el.shapeType === 'flag') {
                        div.style.backgroundColor = el.style.color;
                        div.style.width = el.width + 'px';
                        div.style.height = h + 'px';
                      } else if (el.shapeType === 'bullet') {
                          const icon = div.querySelector('div');
                          if(icon) icon.style.backgroundColor = el.style.color;
                          div.style.width = el.width + 'px';
                      } else {
                        div.style.backgroundColor = el.style.color;
                        div.style.width = el.width + 'px';
                        div.style.height = h + 'px';
                        if (el.shapeType === 'rect') div.style.borderRadius = (el.borderRadius || 0) + 'px';
                      }
                }
            }

            let dragged = null, startX=0, startY=0;
            function startDrag(e) { 
                if(state.mode === 'selecting') return;
                dragged = e.currentTarget; const rect = dragged.getBoundingClientRect(); startX = e.clientX - rect.left; startY = e.clientY - rect.top; selectElement(dragged.id); document.addEventListener('mousemove', onDrag); document.addEventListener('mouseup', endDrag); 
            }
            function onDrag(e) { if(!dragged) return; const cont = els.interactiveArea.getBoundingClientRect(); const x = e.clientX - cont.left - startX; const y = e.clientY - cont.top - startY; dragged.style.left = x + 'px'; dragged.style.top = y + 'px'; const el = state.elements.find(i => i.id === dragged.id); if(el) { el.x = x; el.y = y; } }
            function endDrag() { dragged = null; document.removeEventListener('mousemove', onDrag); document.removeEventListener('mouseup', endDrag); }

            function selectElement(id) {
                state.selectedElementId = id;
                els.inspectorPlaceholder.classList.add('hidden');
                const el = state.elements.find(e => e.id === id);
                if(el) {
                    els.textInspector.classList.remove('hidden');
                    els.imageInspector.classList.add('hidden');
                    els.colorPicker.value = el.style.color;
                    els.opacityInput.value = el.style.opacity || 1;
                    els.opacityValue.innerText = Math.round((el.style.opacity || 1) * 100) + '%';
                    els.rotationInput.value = el.rotation;
                    els.rotationValue.innerText = el.rotation + '°';
                    
                    if(el.type === 'text') {
                        els.textSpecificControls.classList.remove('hidden'); 
                        els.shapeSpecificControls.classList.add('hidden');
                        els.textSizeControl.classList.remove('hidden');
                        els.textSpacingControl.classList.remove('hidden');
                        els.textStrokeControl.classList.remove('hidden');
                        els.opacityControl.classList.remove('hidden');
                        
                        els.selectedTextInput.value = el.content;
                        
                        let currentSize = el.style.fontSize;
                        if(typeof currentSize === 'string') currentSize = parseInt(currentSize.replace('px',''));
                        els.sizeInput.value = currentSize || 30;
                        if(els.sizeValueDisplay) els.sizeValueDisplay.innerText = (currentSize || 30) + 'px';
                        
                        els.boldBtn.classList.toggle('active', el.style.fontWeight === 'bold');
                        els.italicBtn.classList.toggle('active', el.style.fontStyle === 'italic');
                        
                        els.alignLeftBtn.classList.toggle('active', el.style.textAlign === 'left');
                        els.alignCenterBtn.classList.toggle('active', el.style.textAlign === 'center');
                        els.alignRightBtn.classList.toggle('active', el.style.textAlign === 'right');
                        
                        const angle = el.shadowProps ? el.shadowProps.angle : 45; els.shadowAngleInput.value = angle; els.angleValue.innerText = angle + '°';
                    } else if (el.type === 'image') {
                        els.textInspector.classList.add('hidden'); els.imageInspector.classList.remove('hidden');
                        els.imgSizeInput.value = el.width; els.imgSizeValue.innerText = el.width;
                        els.imgRotationInput.value = el.rotation; els.imgRotationValue.innerText = el.rotation + '°';
                    } else if (el.type === 'shape') {
                        els.textSpecificControls.classList.add('hidden');
                        els.textSizeControl.classList.add('hidden');
                        els.textSpacingControl.classList.add('hidden');
                        els.textStrokeControl.classList.add('hidden');
                        els.shapeSpecificControls.classList.remove('hidden');
                        els.opacityControl.classList.remove('hidden');
                        
                        els.shapeWidthInput.value = el.width; els.shapeWidthDisplay.innerText = el.width + 'px';
                        els.shapeHeightInput.value = el.height || el.width; els.shapeHeightDisplay.innerText = (el.height || el.width) + 'px';
                        const angle = el.shadowProps ? el.shadowProps.angle : 45; els.shadowAngleInput.value = angle; els.angleValue.innerText = angle + '°';

                        if(el.shapeType === 'rect') {
                            els.borderRadiusControl.classList.remove('hidden');
                            els.shapeRadiusInput.value = el.borderRadius || 0;
                            els.shapeRadiusDisplay.innerText = (el.borderRadius || 0) + 'px';
                        } else {
                            els.borderRadiusControl.classList.add('hidden');
                        }
                    }
                }
            }

            function updateSelectedElement(prop, value) {
                if (!state.selectedElementId) return;
                const el = state.elements.find(e => e.id === state.selectedElementId);
                const domEl = document.getElementById(state.selectedElementId);
                if (el && domEl) {
                    el[prop] = value;
                    if(prop === 'rotation') domEl.style.transform = `rotate(${value}deg)`;
                    else if(prop === 'content' && el.type === 'text') domEl.innerText = value;
                    else if(prop === 'width') {
                          if(el.type === 'image') { const img = domEl.querySelector('img'); if(img) img.style.width = value + 'px'; } 
                          else if (el.type === 'shape') {
                             const h = el.height || el.width; 
                             if (el.shapeType === 'triangle') { domEl.style.borderLeftWidth = (value/2) + 'px'; domEl.style.borderRightWidth = (value/2) + 'px'; } 
                             else if (el.shapeType === 'bullet') { domEl.style.width = value + 'px'; }
                             else { domEl.style.width = value + 'px'; }
                          }
                    } else if (prop === 'height' && el.type === 'shape') {
                          if (el.shapeType === 'triangle') { domEl.style.borderBottomWidth = value + 'px'; }
                          else if (el.shapeType === 'bullet') { }
                          else { domEl.style.height = value + 'px'; }
                    } else if (prop === 'borderRadius' && el.type === 'shape' && el.shapeType === 'rect') {
                          domEl.style.borderRadius = value + 'px';
                    }
                }
            }
            
            function updateElementById(id, prop, value) {
                const el = state.elements.find(e => e.id === id);
                const domEl = document.getElementById(id);
                if (el && domEl) {
                    el[prop] = value;
                    if(prop === 'rotation') domEl.style.transform = `rotate(${value}deg)`;
                    else if(prop === 'x') domEl.style.left = value + 'px';
                    else if(prop === 'y') domEl.style.top = value + 'px';
                }
            }
            
            function updateElement(prop, val) {
                 const el = state.elements.find(e => e.id === state.selectedElementId);
                 if(el) {
                     el[prop] = val;
                     const dom = document.getElementById(el.id);
                     if(prop === 'rotation') dom.style.transform = `rotate(${val}deg)`;
                     else if (prop === 'x') dom.style.left = val + 'px';
                 }
            }

            function updateSelectedStyle(styleProp, value) {
                if (!state.selectedElementId) return;
                const el = state.elements.find(e => e.id === state.selectedElementId);
                const domEl = document.getElementById(state.selectedElementId);
                if (el && domEl) {
                    el.style[styleProp] = value;
                    if (el.type === 'shape') {
                        if (el.shapeType === 'triangle' && styleProp === 'color') domEl.style.borderBottomColor = value;
                        else if (styleProp === 'color' && el.shapeType === 'bullet') {
                             const icon = domEl.querySelector('div');
                             if(icon) icon.style.backgroundColor = value;
                             el.style.color = value;
                        }
                        else if (styleProp === 'color') domEl.style.backgroundColor = value;
                        else domEl.style[styleProp] = value;
                    } else applyStyles(domEl, el);
                }
            }
            
            function deleteSelectedElement() {
                if(state.selectedElementId) {
                    const domEl = document.getElementById(state.selectedElementId);
                    if (domEl) domEl.remove();
                    state.elements = state.elements.filter(e => e.id !== state.selectedElementId);
                    state.selectedElementId = null;
                    els.textInspector.classList.add('hidden');
                    els.imageInspector.classList.add('hidden');
                    els.inspectorPlaceholder.classList.remove('hidden');
                }
            }

            function centerSelectedElement() {
                if(state.selectedElementId) {
                    const dom = document.getElementById(state.selectedElementId);
                    if (dom) {
                        const containerW = els.interactiveArea.offsetWidth;
                        const elW = dom.offsetWidth;
                        const newX = (containerW - elW) / 2;
                        updateElement('x', newX);
                        dom.style.left = newX + 'px';
                    }
                }
            }

            // --- PROFESSIONAL GENERATION FUNCTION ---
            async function generateBaseArtwork() {
                if(!els.titleInput.value || !els.mood.value) return alert("Compila i campi Titolo e Tema!");
                
                els.loader.classList.remove('hidden');
                els.loaderText.innerText = "la tua cover è in arrivo..........";
                
                els.modificationPrompt.value = ''; 
                state.mode = 'kindle';
                state.lastActiveMode = 'kindle'; 
                
                try {
                    console.log("Iniziando generazione professionale con Nano Banana...");
                    const mockPrompt = (els.titleInput.value || "") + " " + (els.mood.value || "") + " book cover design, high quality, vertical aspect ratio";
                    const randomSeed = Math.floor(Math.random() * 99999);
                    const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(mockPrompt)}?width=800&height=1200&nologo=true&seed=${randomSeed}`;

                    const response = await fetch(imageUrl);
                    if (!response.ok) throw new Error("Errore nel download dell'immagine.");
                    const blob = await response.blob();

                    const reader = new FileReader();
                    reader.onloadend = function() {
                        console.log("Immagine generata con successo!");
                        state.generatedImageB64 = reader.result;
                        state.originalImageB64 = state.generatedImageB64;
                        
                        initKindleCanvas(); 
                        
                        els.modificationArea.classList.remove('hidden');
                        els.designStudio.classList.remove('hidden');
                        els.printSection.classList.remove('hidden');
                        els.exportSection.classList.remove('hidden');
                        
                        if(typeof updatePrintCalculations === 'function') updatePrintCalculations();
                        
                        state.elements = [];
                        state.idCounter = 0;
                        
                        els.loader.classList.add('hidden');
                    }
                    reader.readAsDataURL(blob);

                } catch (error) {
                    console.error("ERRORE API:", error);
                    alert("Errore generazione Nano Banana: " + error.message);
                    els.loader.classList.add('hidden');
                }
            }
            
            // --- MODIFIED RENDER AND DOWNLOAD FUNCTION (PAY-PER-DOWNLOAD) ---
            function renderAndDownload(type) {
                if (!state.generatedImageB64 && !state.printFrontImage) return alert("Nessun design da esportare!");

                let price, itemName;
                if(type === 'kindle') {
                    price = "10.00€"; itemName = "Kindle Cover HD (JPG)";
                } else {
                    price = "20.00€"; itemName = "KDP Print Layout (300DPI)";
                }

                if(confirm(`Vuoi procedere al pagamento di ${price} per scaricare ${itemName}?`)) {
                    els.loader.classList.remove('hidden'); 
                    els.loaderText.innerText = "Reindirizzamento a Stripe in corso...";
                    setTimeout(() => {
                        els.loaderText.innerText = "Pagamento riuscito! Generazione file...";
                        setTimeout(() => { executeDownloadGeneration(type); }, 1000);
                    }, 1500);
                }
            }

            function executeDownloadGeneration(type) {
                    try {
                        const canvas = els.exportCanvas;
                        const ctx = canvas.getContext('2d');
                        let targetW, targetH;
                        let scaleFactor = 1;

                        if (type === 'kindle') {
                            targetW = 1600; targetH = 2400;
                            const viewW = parseFloat(els.interactiveArea.style.width) || 400;
                            scaleFactor = targetW / viewW;
                        } else {
                            const calc = updatePrintCalculations();
                            targetW = calc.pxW; targetH = calc.pxH;
                            const viewW = parseFloat(els.interactiveArea.style.width);
                            if (!viewW) throw new Error("Errore dimensioni canvas. Riprova a generare il layout.");
                            scaleFactor = targetW / viewW;
                        }

                        canvas.width = targetW; canvas.height = targetH;
                        
                        const performDraw = (bgImg) => {
                            if (type === 'kindle') {
                                 const r = bgImg.width / bgImg.height; const tr = targetW / targetH;
                                 let dw, dh, dx, dy;
                                 if(r > tr) { dh = targetH; dw = targetH * r; dx = (targetW-dw)/2; dy=0; }
                                 else { dw = targetW; dh = targetW / r; dy = (targetH-dh)/2; dx=0; }
                                 ctx.drawImage(bgImg, dx, dy, dw, dh);
                            } else {
                                 const calc = updatePrintCalculations();
                                 ctx.fillStyle = els.backColorInput.value; ctx.fillRect(0,0, targetW, targetH);
                                 ctx.fillStyle = els.spineColorInput.value;
                                 const spineStart = calc.bleedPx + calc.frontPx; 
                                 ctx.fillRect(spineStart, 0, calc.spinePx, targetH);

                                 const fx = spineStart + calc.spinePx;
                                 const fw = calc.frontPx + calc.bleedPx; const fh = targetH;
                                 
                                 const imgR = bgImg.width / bgImg.height;
                                 const targetR = fw / fh;
                                 let dW, dH, dX, dY;
                                 if (imgR > targetR) { dH = fh; dW = fh * imgR; dX = fx + (fw - dW)/2; dY = 0; } 
                                 else { dW = fw; dH = fw / imgR; dX = fx; dY = (fh - dH)/2; }
                                 
                                 ctx.save(); ctx.beginPath(); ctx.rect(fx, 0, fw, fh); ctx.clip();
                                 ctx.drawImage(bgImg, dX, dY, dW, dH);
                                 ctx.restore();
                            }

                            state.elements.forEach(el => {
                                 ctx.save();
                                 let rectW = 0, rectH = 0;
                                 const domEl = document.getElementById(el.id);
                                 if (domEl) { rectW = domEl.offsetWidth; rectH = domEl.offsetHeight; } 
                                 else { rectW = el.width || 100; rectH = el.height || el.width || 100; }

                                 const scaledW = rectW * scaleFactor;
                                 const scaledH = rectH * scaleFactor;
                                 const centerX = (el.x * scaleFactor) + (scaledW / 2);
                                 const centerY = (el.y * scaleFactor) + (scaledH / 2);

                                 ctx.translate(centerX, centerY);
                                 ctx.rotate(el.rotation * Math.PI / 180);
                                 ctx.globalAlpha = el.style.opacity || 1;

                                 const drawX = -scaledW / 2; const drawY = -scaledH / 2;
                                 
                                 if(el.type === 'text') {
                                      const fSize = parseFloat(window.getComputedStyle(domEl).fontSize) * scaleFactor;
                                      ctx.font = `${el.style.fontWeight} ${el.style.fontStyle} ${fSize}px ${el.style.fontFamily.replace(/'/g, "")}`;
                                      ctx.fillStyle = el.style.color;
                                      ctx.textBaseline = 'middle'; ctx.textAlign = el.style.textAlign || 'center';
                                      
                                      if(el.shadowProps) {
                                           ctx.shadowColor = el.shadowProps.color;
                                           ctx.shadowBlur = el.shadowProps.blur * scaleFactor;
                                           const rad = el.shadowProps.angle * (Math.PI/180);
                                           ctx.shadowOffsetX = el.shadowProps.offset * Math.cos(rad) * scaleFactor;
                                           ctx.shadowOffsetY = el.shadowProps.offset * Math.sin(rad) * scaleFactor;
                                      }

                                      let textX = 0; const paddingOffset = 4 * scaleFactor;
                                      if (el.style.textAlign === 'center') textX = 0;
                                      else if (el.style.textAlign === 'right') textX = (scaledW / 2) - paddingOffset;
                                      else textX = (-scaledW / 2) + paddingOffset;
                                      
                                      ctx.fillText(el.content, textX, 0); 
                                      
                                      if(parseFloat(el.style.webkitTextStrokeWidth) > 0) {
                                           ctx.strokeStyle = el.style.webkitTextStrokeColor;
                                           ctx.lineWidth = parseFloat(el.style.webkitTextStrokeWidth) * scaleFactor;
                                           ctx.strokeText(el.content, textX, 0); 
                                      }
                                 } else if (el.type === 'image') {
                                      const img = domEl.querySelector('img');
                                      if(img) { ctx.drawImage(img, drawX, drawY, scaledW, scaledH); }
                                 } else if (el.type === 'shape') {
                                      ctx.fillStyle = el.style.color;
                                      if(el.shadowProps) {
                                           ctx.shadowColor = el.shadowProps.color;
                                           ctx.shadowBlur = el.shadowProps.blur * scaleFactor;
                                           const rad = el.shadowProps.angle * (Math.PI/180);
                                           ctx.shadowOffsetX = el.shadowProps.offset * Math.cos(rad) * scaleFactor;
                                           ctx.shadowOffsetY = el.shadowProps.offset * Math.sin(rad) * scaleFactor;
                                      }

                                      if(el.shapeType === 'rect') {
                                           const r = (el.borderRadius || 0) * scaleFactor;
                                           ctx.beginPath();
                                           ctx.moveTo(drawX + r, drawY);
                                           ctx.lineTo(drawX + scaledW - r, drawY);
                                           ctx.quadraticCurveTo(drawX + scaledW, drawY, drawX + scaledW, drawY + r);
                                           ctx.lineTo(drawX + scaledW, drawY + scaledH - r);
                                           ctx.quadraticCurveTo(drawX + scaledW, drawY + scaledH, drawX + scaledW - r, drawY + scaledH);
                                           ctx.lineTo(drawX + r, drawY + scaledH);
                                           ctx.quadraticCurveTo(drawX, drawY + scaledH, drawX, drawY + scaledH - r);
                                           ctx.lineTo(drawX, drawY + r);
                                           ctx.quadraticCurveTo(drawX, drawY, drawX + r, drawY);
                                           ctx.closePath();
                                           ctx.fill();
                                      }
                                      else if(el.shapeType === 'circle') {
                                           ctx.beginPath(); ctx.ellipse(0, 0, scaledW/2, scaledH/2, 0, 0, 2*Math.PI); ctx.fill();
                                      } 
                                      else if (el.shapeType === 'triangle') {
                                           ctx.beginPath(); ctx.moveTo(0, -scaledH/2); ctx.lineTo(drawX + scaledW, drawY + scaledH); ctx.lineTo(drawX, drawY + scaledH); ctx.fill();
                                      }
                                      else {
                                           ctx.fillRect(drawX, drawY, scaledW, scaledH); 
                                      }
                                 }
                                 ctx.restore();
                            });

                            try {
                                const link = document.createElement('a');
                                link.download = `cover-${type}-${Date.now()}.jpg`;
                                link.href = canvas.toDataURL('image/jpeg', 0.92);
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                            } catch(err) {
                                alert("Errore generazione file (canvas troppo grande?). Riprova.");
                            }
                            els.loader.classList.add('hidden');
                        };

                        const imgSource = (type === 'print' && state.printFrontImage) ? state.printFrontImage : state.generatedImageB64;
                        if (!imgSource) {
                            alert("Immagine sorgente mancante.");
                            els.loader.classList.add('hidden');
                            return;
                        }

                        const bgImg = new Image();
                        bgImg.crossOrigin = "anonymous";
                        bgImg.onload = () => performDraw(bgImg);
                        bgImg.onerror = () => { alert("Errore caricamento immagine per esportazione."); els.loader.classList.add('hidden'); };
                        bgImg.src = imgSource;

                    } catch(e) {
                        console.error(e);
                        alert("Errore durante l'esportazione: " + e.message);
                        els.loader.classList.add('hidden');
                    }
            }
            
            els.toggleBarcode.addEventListener('change', (e) => {
                if(e.target.checked) els.barcodeArea.classList.remove('hidden');
                else els.barcodeArea.classList.add('hidden');
            });

            els.toggleGuides.addEventListener('change', (e) => {
                if(e.target.checked) {
                    if(state.mode === 'paperback') {
                          if (!state.paperbackLayout) state.paperbackLayout = updatePrintCalculations();
                          const viewW = parseFloat(els.interactiveArea.style.width);
                          const viewH = parseFloat(els.interactiveArea.style.height);
                          drawKDPGuides(state.paperbackLayout, viewW, viewH);
                          els.guidesOverlay.classList.remove('hidden');
                    }
                } else els.guidesOverlay.classList.add('hidden');
            });

            // --- EVENT LISTENERS ---
            els.runAgentsBtn.addEventListener('click', generateBaseArtwork);
            els.modifyArtworkBtn.addEventListener('click', () => { alert("Work in progress!"); });
            els.undoBtn.addEventListener('click', () => { alert("Undo non disponibile nella demo."); });
            
            els.addGenericTextBtn.addEventListener('click', () => { addElement('text', ''); setTimeout(() => els.selectedTextInput.focus(), 50); });
            els.centerElementBtn.addEventListener('click', centerSelectedElement);
            els.downloadKindleBtn.addEventListener('click', () => renderAndDownload('kindle'));
            els.downloadPrintBtn.addEventListener('click', () => renderAndDownload('print'));
            
            els.trimSizeInput.addEventListener('change', () => { updatePrintCalculations(); if(state.mode === 'paperback') initPaperbackMode(); });
            els.pageCountInput.addEventListener('input', () => { updatePrintCalculations(); if(state.mode === 'paperback') initPaperbackMode(); });
            els.paperTypeInput.addEventListener('change', () => { updatePrintCalculations(); if(state.mode === 'paperback') initPaperbackMode(); });
            
            els.spineColorInput.addEventListener('input', () => { if(state.mode === 'paperback') initPaperbackMode(); });
            els.backColorInput.addEventListener('input', () => { if(state.mode === 'paperback') initPaperbackMode(); });
            
            els.initPaperbackBtn.addEventListener('click', initPaperbackMode);
            
            els.addSpineTextBtn.addEventListener('click', addSpineText);
            els.centerSpineTextBtn.addEventListener('click', centerSpineText);
            
            els.addBackTextBtn.addEventListener('click', addBackText);
            els.centerBackTextBtn.addEventListener('click', centerBackText);
            
            els.addBackImageInput.addEventListener('change', handleImageUpload);
            
            els.selectedTextInput.addEventListener('input', (e) => updateSelectedElement('content', e.target.value));
            els.fontSelector.addEventListener('change', (e) => updateSelectedStyle('fontFamily', e.target.value));
            els.colorPicker.addEventListener('input', (e) => updateSelectedStyle('color', e.target.value));

            els.sizeInput.addEventListener('input', (e) => { 
                els.sizeValueDisplay.innerText = e.target.value + 'px'; 
                const el = state.elements.find(el => el.id === state.selectedElementId);
                if (el) {
                    if (el.type === 'text') updateSelectedStyle('fontSize', e.target.value + 'px'); 
                    else if (el.type === 'shape') updateSelectedElement('width', parseInt(e.target.value));
                }
            });

            els.shapeWidthInput.addEventListener('input', (e) => {
                els.shapeWidthDisplay.innerText = e.target.value + 'px';
                updateSelectedElement('width', parseInt(e.target.value));
            });
            els.shapeHeightInput.addEventListener('input', (e) => {
                els.shapeHeightDisplay.innerText = e.target.value + 'px';
                updateSelectedElement('height', parseInt(e.target.value));
            });
            els.shapeRadiusInput.addEventListener('input', (e) => {
                els.shapeRadiusDisplay.innerText = e.target.value + 'px';
                updateSelectedElement('borderRadius', parseInt(e.target.value));
            });

            els.spacingInput.addEventListener('input', (e) => { els.spacingValue.innerText = e.target.value + 'px'; updateSelectedStyle('letterSpacing', e.target.value + 'px'); });
            
            els.strokeColorPicker.addEventListener('input', (e) => updateSelectedStyle('webkitTextStrokeColor', e.target.value));
            els.strokeWidthInput.addEventListener('input', (e) => updateSelectedStyle('webkitTextStrokeWidth', e.target.value + 'px'));
            els.shadowColorPicker.addEventListener('input', updateShadow);
            els.shadowBlurInput.addEventListener('input', updateShadow);
            els.shadowOffsetInput.addEventListener('input', (e) => { els.offsetValue.innerText = e.target.value + 'px'; updateShadow(); });
            els.shadowAngleInput.addEventListener('input', (e) => { els.angleValue.innerText = e.target.value + '°'; updateShadow(); });
            els.rotationInput.addEventListener('input', (e) => { els.rotationValue.innerText = e.target.value + '°'; updateSelectedElement('rotation', parseInt(e.target.value)); });
            els.resetRotationBtn.addEventListener('click', () => { if(state.selectedElementId) { els.rotationInput.value = 0; els.rotationValue.innerText = '0°'; updateSelectedElement('rotation', 0); } });
            els.rotateNegative90Btn.addEventListener('click', () => { if(state.selectedElementId) { els.rotationInput.value = -90; els.rotationValue.innerText = '-90°'; updateSelectedElement('rotation', -90); } });
            
            els.imgSizeInput.addEventListener('input', (e) => { els.imgSizeValue.innerText = e.target.value; updateSelectedElement('width', parseInt(e.target.value)); });
            els.imgRotationInput.addEventListener('input', (e) => { els.imgRotationValue.innerText = e.target.value + '°'; updateSelectedElement('rotation', parseInt(e.target.value)); });
            
            els.opacityInput.addEventListener('input', (e) => { const val = e.target.value; els.opacityValue.innerText = Math.round(val * 100) + '%'; updateSelectedStyle('opacity', val); });
            
            els.deleteImageBtn.addEventListener('click', deleteSelectedElement);
            els.deleteElementBtn.addEventListener('click', deleteSelectedElement);
            els.aiStyleBtn.addEventListener('click', applyAiStyle);
            
            els.boldBtn.addEventListener('click', () => { const el = state.elements.find(e => e.id === state.selectedElementId); if(el) { const v = el.style.fontWeight === 'bold' ? 'normal' : 'bold'; updateSelectedStyle('fontWeight', v); els.boldBtn.classList.toggle('active'); } });
            els.italicBtn.addEventListener('click', () => { const el = state.elements.find(e => e.id === state.selectedElementId); if(el) { const v = el.style.fontStyle === 'italic' ? 'normal' : 'italic'; updateSelectedStyle('fontStyle', v); els.italicBtn.classList.toggle('active'); } });
            
            els.alignLeftBtn.addEventListener('click', () => updateAlignment('left'));
            els.alignCenterBtn.addEventListener('click', () => updateAlignment('center'));
            els.alignRightBtn.addEventListener('click', () => updateAlignment('right'));

            els.importFrontInput.addEventListener('change', (e) => { const f = e.target.files[0]; if(f) { const r = new FileReader(); r.onload = (ev) => { state.printFrontImage = ev.target.result; if(state.mode==='paperback') initPaperbackMode(); else alert("Img importata"); }; r.readAsDataURL(f); } });
            els.styleRefInput.addEventListener('change', (e) => { const f = e.target.files[0]; if(f) { const r = new FileReader(); r.onload = (ev) => { state.styleReferenceB64 = ev.target.result.split(',')[1]; els.styleRefImg.src = ev.target.result; els.styleRefPreview.classList.remove('hidden'); els.clearStyleRef.classList.remove('hidden'); }; r.readAsDataURL(f); } });
            els.clearStyleRef.addEventListener('click', () => { state.styleReferenceB64 = null; els.styleRefInput.value = ''; els.styleRefPreview.classList.add('hidden'); els.clearStyleRef.classList.add('hidden'); });

            els.resetBtn.addEventListener('click', performReset);
            
            els.addRectBtn.addEventListener('click', () => addElement('shape', 'rect'));
            els.addCircleBtn.addEventListener('click', () => addElement('shape', 'circle'));
            els.addBadgeBtn.addEventListener('click', () => addElement('shape', 'badge'));
            els.addFlagBtn.addEventListener('click', () => addElement('shape', 'flag'));
            els.addBulletBtn.addEventListener('click', () => addElement('shape', 'bullet'));
        });
    </script>
</body>
</html>